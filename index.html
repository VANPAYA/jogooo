<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>æ–°å¹¹ç·šãƒã‚ªãƒ³ãƒ©ãƒ³ â€” Shinkansen Neon Run</title>
  <style>
    :root{
      --bg:#070a10;
      --panel:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.14);
      --txt:#eef2ff;
      --muted:rgba(238,242,255,.70);
      --muted2:rgba(238,242,255,.55);
      --good:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;

      --hue: 200;
      --a1: hsl(calc(var(--hue) - 20) 92% 60%);
      --a2: hsl(var(--hue) 92% 58%);
      --a3: hsl(calc(var(--hue) + 60) 92% 62%);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --r: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:
        radial-gradient(1100px 650px at 70% 10%, rgba(80,180,255,.14), transparent 55%),
        radial-gradient(900px 600px at 15% 30%, rgba(255,80,210,.12), transparent 55%),
        radial-gradient(900px 600px at 60% 90%, rgba(60,255,170,.10), transparent 55%),
        var(--bg);
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    #c{position:fixed; inset:0; width:100vw; height:100vh; display:block}

    .hud{
      position:fixed; top:14px; left:14px; right:14px;
      display:flex; gap:10px; align-items:stretch;
      z-index:10; pointer-events:none;
    }
    .hud>*{pointer-events:auto}
    .left{display:flex; gap:10px; flex-wrap:wrap}
    .right{margin-left:auto; display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end}

    .chip{
      display:flex; gap:10px; align-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid var(--border);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .chip .label{color:var(--muted2); font-size:12px; letter-spacing:.08em; text-transform:uppercase}
    .chip .value{font-weight:900}
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      border-radius:999px;
      border:1px solid var(--border);
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color:var(--txt);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      cursor:pointer;
      font-weight:900; font-size:13px;
      transition: transform .08s ease, border-color .2s ease;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.22)}
    .btn:active{transform: translateY(0) scale(.99)}
    .btn[aria-pressed="true"]{outline:2px solid rgba(80,200,255,.25)}

    .bar{
      width:160px; height:12px; border-radius:999px; overflow:hidden;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.2);
    }
    .bar i{display:block; height:100%; width:50%; border-radius:999px; background: linear-gradient(90deg,var(--a2),var(--a3)); box-shadow:0 0 16px rgba(80,200,255,.28)}
    .bar.shield i{background: linear-gradient(90deg, var(--good), #22c55e); box-shadow:0 0 16px rgba(52,211,153,.22)}
    .bar.slow i{background: linear-gradient(90deg, var(--warn), var(--a3)); box-shadow:0 0 16px rgba(251,191,36,.20)}

    .overlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:18px;
      z-index:20;
      background: radial-gradient(900px 700px at 50% 20%, rgba(0,0,0,.55), rgba(0,0,0,.78));
      backdrop-filter: blur(6px);
    }
    .hidden{display:none!important}
    .panel{
      width:min(980px,100%);
      border-radius: var(--r);
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    header{
      padding:18px 18px 14px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: linear-gradient(90deg, rgba(80,200,255,.12), rgba(255,80,210,.08), rgba(60,255,170,.08));
    }
    h1{margin:0; font-size:22px; letter-spacing:.02em}
    .sub{color:var(--muted); font-size:12.5px; line-height:1.4; margin-top:6px}
    .content{
      padding:18px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:16px;
    }
    @media (max-width: 860px){ .content{grid-template-columns:1fr} .bar{width:140px} }
    .card{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      padding:14px;
    }
    .card h2{margin:0 0 8px; font-size:14px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    .card p{margin:0; color:var(--muted); line-height:1.55; font-size:14px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      border-radius:999px;
      padding:7px 10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      font-size:13px;
      font-weight:900;
    }
    .kbd{
      display:inline-block; padding:3px 8px; border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      font-weight:900; font-size:12px; color:var(--txt);
      margin: 0 3px;
    }

    .touch{
      position:fixed; left:14px; right:14px; bottom:14px;
      display:none; gap:10px; z-index:12; pointer-events:none;
      justify-content:space-between;
    }
    .touch>*{pointer-events:auto}
    .touchBtn{
      flex:1;
      padding:14px 12px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.34);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      display:flex; justify-content:center; align-items:center;
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .touchBtn:active{transform: scale(.99)}
    @media (hover: none) and (pointer: coarse){ .touch{display:flex} }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="left">
      <div class="chip">
        <div>
          <div class="label">Score</div>
          <div class="value" id="score">0</div>
        </div>
        <div>
          <div class="label">Mult</div>
          <div class="value" id="mult">x1.0</div>
        </div>
        <div>
          <div class="label">Best</div>
          <div class="value" id="best">0</div>
        </div>
      </div>

      <div class="chip">
        <div>
          <div class="label">Shield</div>
          <div class="bar shield"><i id="shieldBar"></i></div>
        </div>
        <div>
          <div class="label">Slow</div>
          <div class="bar slow"><i id="slowBar"></i></div>
        </div>
      </div>

      <div class="chip">
        <div>
          <div class="label">Velocidade</div>
          <div class="value" id="spd">1.0x</div>
        </div>
        <div>
          <div class="label">Trilhos</div>
          <div class="value" id="laneTxt">3/5</div>
        </div>
      </div>
    </div>

    <div class="right">
      <button class="btn" id="btnPause">â¸ï¸ Pausar</button>
      <button class="btn" id="btnAudio" aria-pressed="false">ğŸ”‡ Som</button>
      <button class="btn" id="btnRestart">ğŸ” Reiniciar</button>
    </div>
  </div>

  <div class="touch">
    <div class="touchBtn" id="tLeft">â¬…ï¸ Left</div>
    <div class="touchBtn" id="tDash">âš¡ Dash</div>
    <div class="touchBtn" id="tRight">â¡ï¸ Right</div>
  </div>

  <div class="overlay" id="menu">
    <div class="panel">
      <header>
        <h1>æ–°å¹¹ç·šãƒã‚ªãƒ³ãƒ©ãƒ³ â€” Shinkansen Neon Run</h1>
        <div class="sub">Runner arcade em 5 trilhos: desvie, colete tickets, gerencie risco com Shield e Slow Time. Neon japonÃªs + som procedural.</div>
      </header>
      <div class="content">
        <div class="card">
          <h2>Como joga</h2>
          <p>
            VocÃª Ã© um Shinkansen correndo na noite de TÃ³quio. Troque de trilho para evitar barreiras.
            Pegue <b>ğŸ« Tickets</b> para subir score e multiplicador. Pegue <b>ğŸ›¡ï¸ Shield</b> para tankar 1 hit e
            <b>â³ Slow</b> para reduzir a velocidade por alguns segundos.
          </p>
          <div style="height:10px"></div>
          <p>
            Controles: <span class="kbd">â†</span><span class="kbd">â†’</span> trocar trilho â€¢ <span class="kbd">Space</span> Dash (micro-invuln) â€¢
            <span class="kbd">P</span> pausa â€¢ <span class="kbd">M</span> som
          </p>
          <div style="height:10px"></div>
          <div class="card" style="background: rgba(255,255,255,.05);">
            <h2>Setup (estilo trader)</h2>
            <p>
              Prioridade Ã© <b>sobrevivÃªncia</b>: mantenha trilho central como â€œposiÃ§Ã£o neutraâ€ e sÃ³ gira pro extremo quando o fluxo exigir.
              Use Dash como <b>stop de emergÃªncia</b>. Shield Ã© <b>hedge</b>. Slow Ã© <b>reduÃ§Ã£o de volatilidade</b> pra manter consistÃªncia e score.
            </p>
          </div>
          <div style="height:12px"></div>
          <div class="row">
            <button class="btn" id="btnStart">âš”ï¸ Start</button>
            <span class="pill">Mobile: swipe left/right</span>
          </div>
        </div>

        <div class="card">
          <h2>Regras</h2>
          <p>
            â€¢ ColisÃ£o sem Shield = Game Over.<br/>
            â€¢ Dash dÃ¡ uma janela curta de invulnerabilidade e ajuda a atravessar â€œgapsâ€.<br/>
            â€¢ Multiplicador cai levemente quando vocÃª fica muito tempo sem pegar ticket (pressÃ£o de performance).<br/>
            â€¢ A velocidade sobe com o tempo (market acelera).
          </p>
          <div style="height:12px"></div>
          <div class="row">
            <span class="pill">Power-ups: ğŸ›¡ï¸ â³ âš¡</span>
            <span class="pill">ObstÃ¡culos: ğŸš§ â›”</span>
          </div>
          <div style="height:12px"></div>
          <button class="btn" id="btnTheme">ğŸ´ Mudar tema</button>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay hidden" id="over">
    <div class="panel">
      <header>
        <h1>ğŸŒ™ Run encerrada</h1>
        <div class="sub">Resumo da execuÃ§Ã£o e recorde salvo no navegador.</div>
      </header>
      <div class="content">
        <div class="card">
          <h2>Resultado</h2>
          <p id="sum"></p>
          <div style="height:12px"></div>
          <div class="row">
            <span class="pill">Score: <b id="oScore">0</b></span>
            <span class="pill">Best: <b id="oBest">0</b></span>
            <span class="pill">Max Mult: <b id="oMult">x1.0</b></span>
            <span class="pill">Tempo: <b id="oTime">0s</b></span>
          </div>
          <div style="height:12px"></div>
          <div class="row">
            <button class="btn" id="btnAgain">ğŸ” Jogar de novo</button>
            <button class="btn" id="btnBack">ğŸ® Menu</button>
          </div>
        </div>

        <div class="card">
          <h2>Compartilhar</h2>
          <p class="card" style="background: rgba(255,255,255,.05); border-radius: 14px;" id="share"></p>
          <div style="height:12px"></div>
          <p>
            Dica: se quiser, eu transformo isso em <b>modo campanha</b> (estaÃ§Ãµes de trem como fases), com ranking por nome e mais powerups.
          </p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const c = $("c");
  const g = c.getContext("2d");

  const menu = $("menu");
  const over = $("over");

  const scoreEl = $("score");
  const multEl = $("mult");
  const bestEl = $("best");
  const spdEl = $("spd");
  const laneTxt = $("laneTxt");
  const shieldBar = $("shieldBar");
  const slowBar = $("slowBar");

  const btnPause = $("btnPause");
  const btnAudio = $("btnAudio");
  const btnRestart = $("btnRestart");
  const btnStart = $("btnStart");
  const btnTheme = $("btnTheme");
  const btnAgain = $("btnAgain");
  const btnBack = $("btnBack");

  const tLeft = $("tLeft");
  const tRight = $("tRight");
  const tDash = $("tDash");

  const sum = $("sum");
  const oScore = $("oScore");
  const oBest = $("oBest");
  const oMult = $("oMult");
  const oTime = $("oTime");
  const share = $("share");

  // ---------- Persist ----------
  const KEY = "shinkansen-neon-run-v1";
  const load = ()=>{ try{ return JSON.parse(localStorage.getItem(KEY)||"null"); }catch{ return null; } };
  const save = (obj)=>{ try{ localStorage.setItem(KEY, JSON.stringify(obj)); }catch{} };
  const saved = load() || { best: 0, theme: 0 };
  let best = saved.best|0;

  // ---------- Themes ----------
  const THEMES = [
    {name:"Neon", hue:200},
    {name:"Sakura", hue:320},
    {name:"Kitsune", hue:38},
    {name:"Abyss", hue:220},
  ];
  let theme = Math.max(0, Math.min(THEMES.length-1, saved.theme|0));
  const applyTheme = ()=>{
    document.documentElement.style.setProperty("--hue", THEMES[theme].hue);
    btnTheme.textContent = "ğŸ´ Tema: " + THEMES[theme].name;
    save({best, theme});
  };
  applyTheme();

  // ---------- Canvas resize ----------
  let W=0, H=0, DPR=1;
  const resize = ()=>{
    DPR = Math.max(1, Math.min(2, devicePixelRatio || 1));
    W = Math.floor(innerWidth*DPR);
    H = Math.floor(innerHeight*DPR);
    c.width = W; c.height = H;
    c.style.width = innerWidth+"px";
    c.style.height = innerHeight+"px";
  };
  addEventListener("resize", resize);
  resize();

  // ---------- Audio (procedural) ----------
  let audioOn = false;
  let ac=null, master=null;
  const ensureAudio = ()=>{
    if(ac) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    ac = new AC();
    master = ac.createGain();
    master.gain.value = 0;
    master.connect(ac.destination);
  };
  const setAudio = async (on)=>{
    audioOn = on;
    btnAudio.setAttribute("aria-pressed", String(on));
    btnAudio.textContent = on ? "ğŸ”Š Som" : "ğŸ”‡ Som";
    if(on){
      ensureAudio();
      try{ await ac.resume(); }catch{}
      master.gain.cancelScheduledValues(ac.currentTime);
      master.gain.setTargetAtTime(0.14, ac.currentTime, 0.06);
    }else if(master && ac){
      master.gain.cancelScheduledValues(ac.currentTime);
      master.gain.setTargetAtTime(0.0, ac.currentTime, 0.05);
    }
  };
  const beep = (f=440, dur=0.08, type="sine", gain=0.12)=>{
    if(!audioOn || !ac) return;
    const t = ac.currentTime;
    const o = ac.createOscillator();
    const gn = ac.createGain();
    o.type = type;
    o.frequency.setValueAtTime(f, t);
    gn.gain.setValueAtTime(0.0001, t);
    gn.gain.exponentialRampToValueAtTime(gain, t+0.01);
    gn.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.connect(gn); gn.connect(master);
    o.start(t); o.stop(t+dur+0.02);
  };
  const sfx = {
    coin(){ beep(980,0.06,"triangle",0.10); beep(1320,0.05,"sine",0.08); },
    power(){ beep(420,0.08,"square",0.08); beep(680,0.08,"triangle",0.08); },
    hit(){ beep(160,0.12,"sawtooth",0.12); },
    dash(){ beep(520,0.05,"triangle",0.08); },
    start(){ beep(220,0.10,"square",0.08); beep(440,0.08,"triangle",0.08); }
  };

  // ---------- Game State ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const pick = (arr)=>arr[(Math.random()*arr.length)|0];

  const LANES = 5;
  let lane = 2; // 0..4
  let laneX = 0; // smoothed
  let running=false, paused=false, dead=false;

  let score=0;
  let mult=1.0;
  let maxMult=1.0;

  let speed=1.0;      // increases
  let dist=0;         // for spawn pacing
  let tRun=0;

  let shield=0;       // 0..1 (one hit) but with decay bar for display
  let slow=0;         // seconds remaining
  let dashT=0;        // invulnerability seconds

  // Entities
  const obstacles = [];
  const items = []; // {type:"coin|shield|slow", lane, y, r}

  // Background particles (neon rain + torii gates)
  const rain = [];
  const gates = [];
  const initFX = ()=>{
    rain.length=0; gates.length=0;
    const n = Math.round((innerWidth*innerHeight)/24000);
    for(let i=0;i<n;i++){
      rain.push({x:Math.random(), y:Math.random(), v:rand(0.25,1.1), len:rand(0.02,0.08), w:rand(0.0006,0.0018), ho:rand(-40,60), a:rand(0.10,0.26)});
    }
    const m = Math.max(8, Math.floor(innerWidth/120));
    for(let i=0;i<m;i++){
      gates.push({lane:(Math.random()*LANES)|0, y:Math.random(), s:rand(0.15,0.35), wob:rand(0.6,1.5), seed:Math.random()*999});
    }
  };
  initFX();
  addEventListener("resize", initFX);

  // Track geometry
  const track = ()=>{
    const pad = 20*DPR;
    const trackW = Math.min(W*0.86, 820*DPR);
    const trackH = H;
    const x0 = (W-trackW)/2;
    const x1 = x0 + trackW;
    return {x0,x1,trackW,trackH,pad};
  };
  const laneCenterX = (ln)=>{
    const {x0,trackW} = track();
    const seg = trackW / LANES;
    return x0 + seg*(ln+0.5);
  };

  // Spawners
  const spawnObstacle = ()=>{
    const ln = (Math.random()*LANES)|0;
    const kind = Math.random()<0.65 ? "barrier" : "block";
    obstacles.push({
      kind,
      lane: ln,
      y: -120*DPR,
      w: (kind==="barrier") ? 0.74 : 0.86,
      h: (kind==="barrier") ? 68 : 92,
      blink: rand(0.8,1.8),
      seed: Math.random()*999
    });
  };
  const spawnItem = ()=>{
    const ln = (Math.random()*LANES)|0;
    const r = Math.random();
    const type = (r<0.72) ? "coin" : (r<0.86 ? "shield" : "slow");
    items.push({type, lane:ln, y:-90*DPR, r: 16*DPR});
  };

  // Collision (lane-based with y threshold)
  const collide = ()=>{
    // player position
    const px = laneCenterX(laneX);
    const py = H*0.80;
    const seg = track().trackW/LANES;

    // obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      const ox = laneCenterX(o.lane);
      const oy = o.y;
      const ow = seg*o.w;
      const oh = o.h*DPR;

      const hitY = Math.abs(oy - py) < (oh*0.55 + 18*DPR);
      const hitX = Math.abs(ox - px) < (ow*0.45 + 16*DPR);
      if(hitX && hitY){
        obstacles.splice(i,1);
        if(dashT>0){
          // dash ignores
          return;
        }
        if(shield>0){
          shield = 0;
          sfx.hit();
          return;
        }
        // dead
        dead = true;
        running = false;
        paused = false;
        sfx.hit();
        endRun();
        return;
      }
    }

    // items
    for(let i=items.length-1;i>=0;i--){
      const it = items[i];
      const ix = laneCenterX(it.lane);
      const iy = it.y;
      const hitY = Math.abs(iy - py) < (it.r + 18*DPR);
      const hitX = Math.abs(ix - px) < (it.r + 16*DPR);
      if(hitX && hitY){
        items.splice(i,1);
        if(it.type==="coin"){
          score += Math.round(18 * mult);
          mult = clamp(mult + 0.06, 1.0, 6.0);
          maxMult = Math.max(maxMult, mult);
          sfx.coin();
        }else if(it.type==="shield"){
          shield = 1;
          score += Math.round(35 * mult);
          sfx.power();
        }else{
          slow = 4.2;
          score += Math.round(28 * mult);
          sfx.power();
        }
      }
    }
  };

  // Multiplicador â€œdecaiâ€ se ficar sem ticket (pressÃ£o)
  let multHeat=0;
  const multDecay = (dt)=>{
    multHeat += dt;
    if(multHeat > 1.25){
      multHeat = 0;
      mult = lerp(mult, 1.0, 0.06);
      if(mult < 1.02) mult = 1.0;
    }
  };
  const multBoostWindow = ()=>{ multHeat = 0; };

  // HUD updates
  const hud = ()=>{
    scoreEl.textContent = score|0;
    multEl.textContent = "x" + (Math.round(mult*10)/10).toFixed(1);
    bestEl.textContent = best|0;
    spdEl.textContent = (Math.round(speed*10)/10).toFixed(1) + "x";
    laneTxt.textContent = (Math.round(laneX)+1) + "/5";
    shieldBar.style.width = (shield>0 ? 100 : 0) + "%";
    slowBar.style.width = clamp((slow/4.2)*100,0,100) + "%";
  };

  // ---------- Game flow ----------
  const resetRun = ()=>{
    lane = 2;
    laneX = 2;
    score = 0;
    mult = 1.0;
    maxMult = 1.0;
    speed = 1.0;
    dist = 0;
    tRun = 0;
    shield = 0;
    slow = 0;
    dashT = 0;
    obstacles.length=0;
    items.length=0;
    dead=false;
    hud();
  };

  const startRun = ()=>{
    resetRun();
    menu.classList.add("hidden");
    over.classList.add("hidden");
    running = true;
    paused = false;
    btnPause.textContent = "â¸ï¸ Pausar";
    sfx.start();
  };

  const endRun = ()=>{
    // best
    best = Math.max(best, score|0);
    save({best, theme});

    const sec = Math.max(0, tRun);
    oScore.textContent = score|0;
    oBest.textContent = best|0;
    oMult.textContent = "x" + (Math.round(maxMult*10)/10).toFixed(1);
    oTime.textContent = Math.round(sec) + "s";

    sum.textContent = `VocÃª durou ${Math.round(sec)}s. Max mult ${ (Math.round(maxMult*10)/10).toFixed(1) }x. Velocidade final ${(Math.round(speed*10)/10).toFixed(1)}x.`;
    share.textContent = `æ–°å¹¹ç·šãƒã‚ªãƒ³ãƒ©ãƒ³ | Score:${score|0} | Best:${best|0} | MaxMult:x${(Math.round(maxMult*10)/10).toFixed(1)} | Time:${Math.round(sec)}s`;

    over.classList.remove("hidden");
  };

  const togglePause = ()=>{
    if(!running && !paused) return;
    paused = !paused;
    btnPause.textContent = paused ? "â–¶ï¸ Voltar" : "â¸ï¸ Pausar";
  };

  // Dash: micro-invuln
  const dash = ()=>{
    if(!running || paused) return;
    if(dashT>0) return;
    dashT = 0.22; // invuln
    sfx.dash();
    // tiny score for skill
    score += Math.round(6 * mult);
  };

  // Lane change
  const moveLane = (dir)=>{
    if(!running || paused) return;
    lane = clamp(lane + dir, 0, LANES-1);
  };

  // ---------- Inputs ----------
  addEventListener("keydown",(e)=>{
    const k = e.key.toLowerCase();
    if(k==="p"){ togglePause(); return; }
    if(k==="m"){ setAudio(!audioOn); return; }
    if(k==="r"){ startRun(); return; }
    if(k===" "){ dash(); return; }
    if(!running || paused) return;
    if(k==="arrowleft" || k==="a") moveLane(-1);
    if(k==="arrowright" || k==="d") moveLane(+1);
  });

  btnPause.addEventListener("click", togglePause);
  btnAudio.addEventListener("click", ()=>setAudio(!audioOn));
  btnRestart.addEventListener("click", startRun);
  btnStart.addEventListener("click", startRun);
  btnAgain.addEventListener("click", startRun);
  btnBack.addEventListener("click", ()=>{
    over.classList.add("hidden");
    menu.classList.remove("hidden");
  });
  btnTheme.addEventListener("click", ()=>{
    theme = (theme+1)%THEMES.length;
    applyTheme();
  });

  tLeft.addEventListener("click", ()=>moveLane(-1));
  tRight.addEventListener("click", ()=>moveLane(+1));
  tDash.addEventListener("click", dash);

  // Swipe controls
  let touchX=0, touchY=0, touching=false;
  c.addEventListener("touchstart",(e)=>{
    const t = e.touches[0];
    touchX = t.clientX; touchY = t.clientY; touching=true;
  }, {passive:true});
  c.addEventListener("touchmove",(e)=>{
    if(!touching) return;
    const t = e.touches[0];
    const dx = t.clientX - touchX;
    const dy = t.clientY - touchY;
    // horizontal swipe to change lane
    if(Math.abs(dx) > 28 && Math.abs(dx) > Math.abs(dy)){
      moveLane(dx>0 ? +1 : -1);
      touchX = t.clientX; touchY = t.clientY;
    }
    // vertical swipe up => dash
    if(dy < -50 && Math.abs(dy) > Math.abs(dx)+12){
      dash();
      touchX = t.clientX; touchY = t.clientY;
    }
  }, {passive:true});
  c.addEventListener("touchend",()=>touching=false,{passive:true});

  // ---------- Drawing ----------
  const roundRect = (ctx,x,y,w,h,r)=>{
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  };

  const drawTrack = (t)=>{
    const {x0,x1,trackW} = track();
    const y0 = 0, y1 = H;

    // track base
    g.save();
    g.globalAlpha = 1;
    const bg = g.createLinearGradient(0,0,0,H);
    bg.addColorStop(0, "rgba(0,0,0,0.20)");
    bg.addColorStop(1, "rgba(0,0,0,0.62)");
    g.fillStyle = bg;
    roundRect(g, x0, y0-40*DPR, trackW, H+80*DPR, 26*DPR);
    g.fill();

    // lane lines
    const seg = trackW/LANES;
    for(let i=1;i<LANES;i++){
      const x = x0 + seg*i;
      g.strokeStyle = `rgba(255,255,255,0.10)`;
      g.lineWidth = 2*DPR;
      g.setLineDash([12*DPR, 18*DPR]);
      g.lineDashOffset = -t*180*DPR*(0.7+speed*0.2);
      g.beginPath();
      g.moveTo(x, y0);
      g.lineTo(x, y1);
      g.stroke();
    }
    g.setLineDash([]);

    // neon edges
    g.globalCompositeOperation = "lighter";
    g.strokeStyle = `hsla(${THEMES[theme].hue}, 92%, 60%, 0.25)`;
    g.lineWidth = 4*DPR;
    roundRect(g, x0, y0-40*DPR, trackW, H+80*DPR, 26*DPR);
    g.stroke();

    g.restore();
  };

  const drawRain = (dt)=>{
    const hue = THEMES[theme].hue;
    g.save();
    g.globalCompositeOperation = "lighter";
    for(const d of rain){
      d.y += dt * d.v * (0.9 + speed*0.4);
      if(d.y > 1.2){ d.y = -0.2; d.x = Math.random(); }
      const x = d.x * W;
      const y = d.y * H;
      const len = d.len * H;
      const w = Math.max(1, d.w * W);
      g.strokeStyle = `hsla(${hue + d.ho},92%,62%,${d.a})`;
      g.lineWidth = w;
      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x, y + len);
      g.stroke();
    }
    g.restore();
  };

  const drawTorii = (t, dt)=>{
    const hue = THEMES[theme].hue;
    const {x0,trackW} = track();
    const seg = trackW/LANES;

    g.save();
    g.globalAlpha = 0.85;

    for(const gate of gates){
      gate.y += dt * (0.18 + speed*0.18);
      if(gate.y > 1.25){
        gate.y = -0.25;
        gate.lane = (Math.random()*LANES)|0;
        gate.s = rand(0.14,0.34);
        gate.seed = Math.random()*999;
      }
      const depth = 1 - gate.y; // near bottom smaller alpha
      const scale = gate.s * (0.55 + (1-depth)*0.75);
      const cx = x0 + seg*(gate.lane+0.5);
      const yy = gate.y * H;

      const w = seg * 0.95 * scale;
      const h = (110*DPR) * scale;

      const wob = Math.sin(t*gate.wob + gate.seed)*2*DPR*scale;

      // frame
      g.fillStyle = `rgba(0,0,0,0.22)`;
      roundRect(g, cx-w/2, yy-h/2, w, h, 10*DPR*scale);
      g.fill();

      // neon outline
      g.globalCompositeOperation = "lighter";
      const a = 0.10 + 0.08*(1-depth);
      g.strokeStyle = `hsla(${hue + 60}, 92%, 62%, ${a})`;
      g.lineWidth = 3*DPR*scale;
      roundRect(g, cx-w/2 + wob, yy-h/2, w, h, 10*DPR*scale);
      g.stroke();
      g.globalCompositeOperation = "source-over";
    }

    g.restore();
  };

  const drawPlayer = (t)=>{
    const {trackW,x0} = track();
    const seg = trackW/LANES;
    const px = laneCenterX(laneX);
    const py = H*0.80;

    const w = seg*0.62;
    const h = 92*DPR;

    // glow trail
    g.save();
    g.globalCompositeOperation = "lighter";
    const hue = THEMES[theme].hue;
    const glowA = dashT>0 ? 0.32 : 0.18;
    const gr = g.createRadialGradient(px,py,0, px,py, 180*DPR);
    gr.addColorStop(0, `hsla(${hue},92%,62%,${glowA})`);
    gr.addColorStop(1, "rgba(0,0,0,0)");
    g.fillStyle = gr;
    g.fillRect(px-220*DPR, py-220*DPR, 440*DPR, 440*DPR);

    // train body
    g.globalCompositeOperation = "source-over";
    g.fillStyle = "rgba(255,255,255,0.10)";
    roundRect(g, px-w/2, py-h/2, w, h, 18*DPR);
    g.fill();

    // cockpit stripe
    g.fillStyle = `hsla(${hue+10}, 92%, 62%, 0.32)`;
    roundRect(g, px-w*0.26, py-h*0.20, w*0.52, h*0.52, 14*DPR);
    g.fill();

    // nose light
    g.globalCompositeOperation = "lighter";
    g.fillStyle = `hsla(${hue+40}, 92%, 62%, ${dashT>0 ? 0.60 : 0.40})`;
    g.beginPath();
    g.arc(px, py-h*0.34, 10*DPR, 0, Math.PI*2);
    g.fill();

    // shield ring
    if(shield>0){
      g.strokeStyle = "rgba(52,211,153,0.55)";
      g.lineWidth = 3*DPR;
      g.beginPath();
      g.arc(px, py, 48*DPR, 0, Math.PI*2);
      g.stroke();
    }

    // dash ring
    if(dashT>0){
      const p = dashT/0.22;
      g.strokeStyle = `rgba(251,191,36,${0.55*p})`;
      g.lineWidth = 4*DPR;
      g.beginPath();
      g.arc(px, py, 64*DPR*(1.0+(1-p)*0.35), 0, Math.PI*2);
      g.stroke();
    }

    g.restore();
  };

  const drawObstacles = (t, dt)=>{
    const hue = THEMES[theme].hue;
    const {trackW} = track();
    const seg = trackW/LANES;

    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.y += (260*DPR) * dt * speed * (slow>0 ? 0.55 : 1.0);
      if(o.y > H + 140*DPR){
        obstacles.splice(i,1);
        // reward: passou risco sem bater
        score += Math.round(6 * mult);
        continue;
      }
      const x = laneCenterX(o.lane);
      const w = seg*o.w;
      const h = o.h*DPR;

      g.save();
      g.fillStyle = "rgba(0,0,0,0.30)";
      roundRect(g, x-w/2, o.y-h/2, w, h, 16*DPR);
      g.fill();

      g.globalCompositeOperation = "lighter";
      const a = 0.16 + 0.10*Math.sin(t*o.blink + o.seed);
      g.strokeStyle = `hsla(${hue + (o.kind==="barrier"?140:20)}, 92%, 62%, ${a})`;
      g.lineWidth = 3*DPR;
      roundRect(g, x-w/2, o.y-h/2, w, h, 16*DPR);
      g.stroke();

      // symbol
      g.globalCompositeOperation = "source-over";
      g.fillStyle = "rgba(255,255,255,0.58)";
      g.font = `${Math.floor(20*DPR)}px "Noto Sans JP", ui-sans-serif`;
      g.textAlign = "center";
      g.fillText(o.kind==="barrier" ? "ğŸš§" : "â›”", x, o.y + 7*DPR);

      g.restore();
    }
  };

  const drawItems = (t, dt)=>{
    const hue = THEMES[theme].hue;
    for(let i=items.length-1;i>=0;i--){
      const it = items[i];
      it.y += (240*DPR) * dt * speed * (slow>0 ? 0.55 : 1.0);
      if(it.y > H + 120*DPR){
        items.splice(i,1);
        continue;
      }
      const x = laneCenterX(it.lane);
      const y = it.y;

      g.save();
      g.globalCompositeOperation = "lighter";
      const glow = g.createRadialGradient(x,y,0, x,y, 70*DPR);
      const col = it.type==="coin" ? `hsla(${hue+20},92%,62%,0.20)`
                : it.type==="shield" ? "rgba(52,211,153,0.20)"
                : "rgba(251,191,36,0.18)";
      glow.addColorStop(0, col);
      glow.addColorStop(1, "rgba(0,0,0,0)");
      g.fillStyle = glow;
      g.fillRect(x-90*DPR, y-90*DPR, 180*DPR, 180*DPR);

      g.globalCompositeOperation = "source-over";
      g.fillStyle = "rgba(255,255,255,0.10)";
      g.beginPath(); g.arc(x,y, 22*DPR, 0, Math.PI*2); g.fill();

      g.fillStyle = "rgba(255,255,255,0.80)";
      g.font = `${Math.floor(18*DPR)}px ui-sans-serif`;
      g.textAlign = "center";
      g.fillText(it.type==="coin" ? "ğŸ«" : (it.type==="shield" ? "ğŸ›¡ï¸" : "â³"), x, y + 6*DPR);

      g.restore();
    }
  };

  const drawVignette = ()=>{
    g.save();
    const vg = g.createRadialGradient(W*0.5,H*0.45,0, W*0.5,H*0.55, Math.max(W,H)*0.7);
    vg.addColorStop(0, `rgba(0,0,0,0)`);
    vg.addColorStop(1, `rgba(0,0,0,0.55)`);
    g.fillStyle = vg;
    g.fillRect(0,0,W,H);
    g.restore();
  };

  const drawPaused = ()=>{
    g.save();
    g.globalAlpha = 0.88;
    g.fillStyle = "rgba(0,0,0,0.35)";
    g.fillRect(0,0,W,H);
    g.fillStyle = "rgba(255,255,255,0.85)";
    g.font = `${Math.floor(44*DPR)}px ui-sans-serif`;
    g.textAlign = "center";
    g.fillText("â¸ï¸ PAUSADO", W/2, H/2);
    g.restore();
  };

  // ---------- Music tick (ambient) ----------
  let musicT=0, step=0;
  const music = (dt)=>{
    if(!audioOn || !ac) return;
    musicT += dt;
    const stepDur = (slow>0 ? 0.26 : 0.22) / (0.95 + speed*0.06);
    if(musicT < stepDur) return;
    musicT = 0; step++;

    const base = 164 + (speed*8); // slight rise
    const scale = [0,3,5,7,10,12];
    const n = scale[step % scale.length];
    const n2 = scale[(step+2)%scale.length];

    const f1 = base * Math.pow(2, n/12);
    const f2 = base * Math.pow(2, n2/12);

    beep(f1, 0.06, "triangle", 0.06);
    if(step%2===0) beep(f2*2, 0.05, "sine", 0.04);
    if(step%4===0) beep(base/2, 0.06, "square", 0.03);
  };

  // ---------- Loop ----------
  let last = performance.now();
  const loop = (now)=>{
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    // background always
    const t = now/1000;

    // clear
    g.clearRect(0,0,W,H);

    // FX
    drawRain(dt);
    drawTorii(t, dt);
    drawTrack(t);

    // gameplay
    if(running && !paused){
      tRun += dt;

      // speed ramps
      speed += dt*0.035;
      if(score>600) speed += dt*0.010;
      if(score>1200) speed += dt*0.012;

      // slow time countdown
      if(slow>0) slow = Math.max(0, slow - dt);

      // dash countdown
      if(dashT>0) dashT = Math.max(0, dashT - dt);

      // smooth lane
      laneX = lerp(laneX, lane, 1 - Math.pow(0.001, dt));

      // spawn pacing
      dist += dt * speed * (slow>0 ? 0.55 : 1.0);

      // obstacles spawn: increases with speed
      const obstEvery = clamp(1.05 - speed*0.08, 0.48, 0.95);
      if(dist > obstEvery){
        dist = 0;
        spawnObstacle();
        if(Math.random() < 0.55) spawnObstacle();
        // items sometimes
        if(Math.random() < 0.75) spawnItem();
      }

      // mult decay pressure
      multDecay(dt);

      // draw + update entities
      drawItems(t, dt);
      drawObstacles(t, dt);

      // collisions
      collide();

      // bonus: if you collect anything, reset decay window
      // (we detect by bumping multHeat on coin; simplest: coin sfx implies coin, but not tracked)
      // We'll approximate: whenever items are few, don't decay too hard:
      if(items.length > 0) multBoostWindow();

      // HUD
      hud();

      // music
      music(dt);
    }else{
      // still draw entities for atmosphere if menu open
      // (no movement for obstacles/items when not running)
      drawItems(t, 0);
      drawObstacles(t, 0);
      laneX = lerp(laneX, lane, 1 - Math.pow(0.001, dt));
      hud();
    }

    // player always
    drawPlayer(t);

    // vignette
    drawVignette();

    // paused overlay
    if(paused && running) drawPaused();

    requestAnimationFrame(loop);
  };
  requestAnimationFrame(loop);

  // init HUD
  bestEl.textContent = best|0;
  hud();

  // enable audio on mobile after gesture
  menu.addEventListener("click", ()=>{ if(ac) ac.resume().catch(()=>{}); });

})();
</script>
</body>
</html>
