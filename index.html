<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢å…¨çŸ¥å…¨èƒ½ â€” å¤œã®æ¼¢å­—ãƒãƒˆãƒ«</title>
  <meta name="description" content="Jogo completo para GitHub Pages: batalha + quiz de kanji com estÃ©tica japonesa, trilha procedural, mobile e salvamento." />
  <style>
    :root{
      --bg:#070a10;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);
      --border:rgba(255,255,255,.14);
      --txt:#eef2ff;
      --muted:rgba(238,242,255,.70);
      --muted2:rgba(238,242,255,.55);
      --good:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;

      --hue: 196;
      --a1: hsl(calc(var(--hue) - 20) 92% 60%);
      --a2: hsl(var(--hue) 92% 58%);
      --a3: hsl(calc(var(--hue) + 60) 92% 62%);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 70% 10%, rgba(80,180,255,.14), transparent 55%),
                  radial-gradient(900px 600px at 15% 30%, rgba(255,80,210,.12), transparent 55%),
                  radial-gradient(900px 600px at 60% 90%, rgba(60,255,170,.10), transparent 55%),
                  var(--bg);
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      overflow:hidden;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Canvas */
    #stage{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
      background: transparent;
    }

    /* Top HUD */
    .hud{
      position:fixed; top:14px; left:14px; right:14px;
      display:flex; gap:10px; align-items:stretch;
      z-index:10;
      pointer-events:none;
    }
    .hud > *{ pointer-events:auto; }

    .chip{
      display:flex; gap:10px; align-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
      border:1px solid var(--border);
      border-radius: 999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .chip .label{ color:var(--muted2); font-size:12px; letter-spacing:.08em; text-transform:uppercase; }
    .chip .value{ font-weight:700; }
    .hud .left{ display:flex; gap:10px; flex-wrap:wrap; }
    .hud .right{ margin-left:auto; display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }

    .bar{
      width:180px;
      height:12px;
      border-radius:999px;
      overflow:hidden;
      border:1px solid var(--border);
      background: rgba(255,255,255,.05);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.2);
    }
    .bar > i{
      display:block; height:100%;
      width:50%;
      background: linear-gradient(90deg, var(--a2), var(--a3));
      border-radius:999px;
      box-shadow: 0 0 16px rgba(80,200,255,.35);
    }
    .bar.hp > i{ background: linear-gradient(90deg, var(--good), #22c55e); box-shadow: 0 0 16px rgba(52,211,153,.35); }
    .bar.enemy > i{ background: linear-gradient(90deg, #fb7185, #f97316); box-shadow: 0 0 16px rgba(251,113,133,.35); }

    .btn{
      display:inline-flex; gap:8px; align-items:center; justify-content:center;
      border-radius: 999px;
      border:1px solid var(--border);
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color: var(--txt);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      cursor:pointer;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
      font-weight:700;
      font-size:13px;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.22); }
    .btn:active{ transform: translateY(0px) scale(.99); }
    .btn[aria-pressed="true"]{ outline:2px solid rgba(80,200,255,.25); }

    /* Main overlay panels */
    .overlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      z-index:20;
      padding:18px;
      background: radial-gradient(900px 700px at 50% 20%, rgba(0,0,0,.55), rgba(0,0,0,.76));
      backdrop-filter: blur(6px);
    }
    .hidden{ display:none !important; }

    .panel{
      width:min(980px, 100%);
      border-radius: var(--radius);
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel header{
      padding:18px 18px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(90deg, rgba(80,200,255,.12), rgba(255,80,210,.08), rgba(60,255,170,.08));
    }
    .title{
      display:flex; gap:12px; align-items:flex-end; flex-wrap:wrap;
    }
    .title h1{
      margin:0;
      font-size:22px;
      letter-spacing:.02em;
    }
    .title .sub{
      color:var(--muted);
      font-size:12.5px;
      line-height:1.4;
    }
    .panel .content{
      padding:18px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:16px;
    }
    @media (max-width: 860px){
      .panel .content{ grid-template-columns: 1fr; }
      .bar{ width:150px; }
    }

    .card{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      padding:14px;
    }
    .card h2{ margin:0 0 8px; font-size:14px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase; }
    .card p{ margin:0; color:var(--muted); line-height:1.55; font-size:14px; }
    .kbd{
      display:inline-block;
      padding:3px 8px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      font-weight:800;
      font-size:12px;
      color:var(--txt);
      margin: 0 3px;
    }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 520px){ .grid2{ grid-template-columns: 1fr; } }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill{
      border-radius:999px;
      padding:7px 10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      font-size:13px;
    }

    /* Battle UI bottom */
    .battleUI{
      position:fixed;
      left:14px; right:14px; bottom:14px;
      z-index:12;
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      pointer-events:none;
    }
    .battleUI > *{ pointer-events:auto; }

    .question{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
      padding:12px 12px;
      border-radius: var(--radius);
      border:1px solid var(--border);
      background: rgba(0,0,0,.36);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .qLeft{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .kanjiBox{
      width:58px; height:58px;
      display:grid; place-items:center;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    .kanjiBox b{
      font-size:30px;
      text-shadow: 0 0 18px rgba(80,200,255,.35);
    }
    .qMeta{ display:flex; flex-direction:column; gap:4px; min-width: 220px; }
    .qMeta .hint{ color:var(--muted2); font-size:12px; letter-spacing:.06em; text-transform:uppercase; }
    .qMeta .prompt{ font-size:14px; color:var(--txt); }
    .timer{
      display:flex; align-items:center; gap:10px;
      color:var(--muted);
      font-size:12px;
    }
    .tinyBar{
      width:170px; height:10px; border-radius:999px; overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
    }
    .tinyBar i{
      display:block; height:100%; width:100%;
      background: linear-gradient(90deg, var(--warn), var(--a3));
      box-shadow: 0 0 16px rgba(251,191,36,.25);
    }

    .answers{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 680px){ .answers{ grid-template-columns: 1fr; } }

    .ans{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      padding:12px;
      cursor:pointer;
      transition: transform .08s ease, border-color .15s ease, filter .15s ease;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .ans:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.22); }
    .ans:active{ transform: translateY(0px) scale(.99); }
    .ans .k{
      color:var(--muted2);
      font-weight:900;
      width:28px; height:28px;
      display:grid; place-items:center;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.15);
      font-size:12px;
      flex: 0 0 auto;
    }
    .ans .t{
      font-weight:900;
      font-size:14px;
    }
    .ans .s{
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
      opacity:.9;
    }
    .ans.good{ border-color: rgba(52,211,153,.55); filter: drop-shadow(0 0 14px rgba(52,211,153,.18)); }
    .ans.bad{ border-color: rgba(251,113,133,.55); filter: drop-shadow(0 0 14px rgba(251,113,133,.18)); }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      top:84px;
      z-index:30;
      padding:10px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.42);
      box-shadow: var(--shadow);
      color: var(--txt);
      font-weight:800;
      font-size:13px;
      letter-spacing:.02em;
      backdrop-filter: blur(10px);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      display:flex; gap:10px; align-items:center;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(0);
    }
    .toast i{
      width:10px; height:10px; border-radius:99px;
      background: var(--a2);
      box-shadow: 0 0 14px rgba(80,200,255,.35);
    }

    /* Small footer tips */
    .footerTips{
      margin-top:10px;
      display:flex; gap:10px; flex-wrap:wrap;
      color:var(--muted2);
      font-size:12px;
    }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .select{
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.25);
      color: var(--txt);
      padding:9px 10px;
      font-weight:800;
      cursor:pointer;
    }

    .tag{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      font-size:13px;
      font-weight:800;
    }

    /* Touch controls */
    .touchPad{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:13;
      display:none;
      gap:10px;
      pointer-events:none;
    }
    .touchPad > *{ pointer-events:auto; }
    .touchBtn{
      width:54px; height:54px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.34);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      display:grid; place-items:center;
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .touchBtn:active{ transform: scale(.98); }
    @media (hover: none) and (pointer: coarse){
      .touchPad{ display:flex; }
    }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div class="left">
      <div class="chip">
        <div>
          <div class="label">Score</div>
          <div class="value" id="score">0</div>
        </div>
        <div>
          <div class="label">Combo</div>
          <div class="value" id="combo">x1</div>
        </div>
      </div>

      <div class="chip">
        <div>
          <div class="label">VocÃª</div>
          <div class="bar hp"><i id="hpBar"></i></div>
        </div>
        <div>
          <div class="label">Inimigo</div>
          <div class="bar enemy"><i id="enemyBar"></i></div>
        </div>
      </div>

      <div class="chip">
        <div>
          <div class="label">Noite</div>
          <div class="bar"><i id="moonBar"></i></div>
        </div>
      </div>
    </div>

    <div class="right">
      <button class="btn" id="btnPause" title="Pausar (P)">â¸ï¸ Pausar</button>
      <button class="btn" id="btnAudio" aria-pressed="false" title="Som (M)">ğŸ”‡ Som</button>
      <select class="select" id="langSel" title="Idioma">
        <option value="pt">PT</option>
        <option value="jp">JP</option>
        <option value="en">EN</option>
      </select>
    </div>
  </div>

  <!-- Battle UI -->
  <div class="battleUI" id="battleUI">
    <div class="question">
      <div class="qLeft">
        <div class="kanjiBox"><b id="kanjiChar">å¤œ</b></div>
        <div class="qMeta">
          <div class="hint" id="qHint">Escolha a leitura (ã‹ãª)</div>
          <div class="prompt" id="qPrompt">Qual Ã© a leitura correta?</div>
        </div>
      </div>

      <div class="timer">
        <span class="mono" id="timerTxt">10.0s</span>
        <div class="tinyBar"><i id="timeBar"></i></div>
      </div>
    </div>

    <div class="answers" id="answers"></div>

    <div class="row" style="justify-content:space-between; gap:12px;">
      <div class="row">
        <span class="tag" id="itemOfuda">ğŸ§¿ Ofuda: <b id="ofudaN">2</b></span>
        <span class="tag" id="itemSmoke">ğŸŒ«ï¸ FumaÃ§a: <b id="smokeN">1</b></span>
      </div>
      <div class="footerTips" id="tips">
        <span>Teclas: <span class="kbd">1</span><span class="kbd">2</span><span class="kbd">3</span><span class="kbd">4</span></span>
        <span>Itens: <span class="kbd">H</span> cura, <span class="kbd">J</span> pular</span>
        <span>Pausar: <span class="kbd">P</span> â€¢ Som: <span class="kbd">M</span></span>
      </div>
    </div>
  </div>

  <!-- Touch pad -->
  <div class="touchPad">
    <div class="touchBtn" id="tHeal" title="Cura (H)">ğŸ§¿</div>
    <div class="touchBtn" id="tSkip" title="Pular (J)">ğŸŒ«ï¸</div>
  </div>

  <!-- Start / Menu -->
  <div class="overlay" id="menu">
    <div class="panel">
      <header>
        <div class="title">
          <h1>ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢å…¨çŸ¥å…¨èƒ½ â€” å¤œã®æ¼¢å­—ãƒãƒˆãƒ«</h1>
          <div class="sub" id="menuSub">Batalha/quiz de kanji no neon de TÃ³quio. Suba combo, use ofuda, sobreviva Ã  Lua de Sangue.</div>
        </div>
      </header>

      <div class="content">
        <div class="card">
          <h2 id="storyT">HistÃ³ria</h2>
          <p id="storyP">
            Na noite em que a <b>Lua de Sangue</b> nasce, os yokai atravessam o vÃ©u. VocÃª Ã© um caÃ§ador
            que selou um pacto: <b>vencer usando conhecimento</b>. Cada kanji correto vira um golpe.
            Cada erro alimenta a escuridÃ£o.
          </p>

          <div style="height:12px"></div>

          <div class="grid2">
            <div class="card">
              <h2 id="howT">Como jogar</h2>
              <p id="howP">
                Responda antes do tempo acabar. Acertos aumentam <b>combo</b> e dÃ£o mais dano.
                Errar tira vida e quebra o ritmo. Itens:
                <b>Ofuda</b> cura; <b>FumaÃ§a</b> pula uma pergunta (mas reduz combo).
              </p>
            </div>
            <div class="card">
              <h2 id="modeT">Config</h2>
              <div class="row" style="margin-top:6px">
                <span class="pill" id="bestPill">Recorde: <b id="best">0</b></span>
                <span class="pill">Dificuldade: <b id="diffTxt">Normal</b></span>
                <button class="btn" id="btnDiff">âš™ï¸ Alternar</button>
              </div>
              <div class="row" style="margin-top:10px">
                <span class="pill">Tema: <b id="themeTxt">Neon</b></span>
                <button class="btn" id="btnTheme">ğŸ´ Mudar</button>
              </div>
              <div class="row" style="margin-top:10px">
                <button class="btn" id="btnStart">âš”ï¸ ComeÃ§ar</button>
                <button class="btn" id="btnTutorial">ğŸ“œ Tutorial rÃ¡pido</button>
              </div>
            </div>
          </div>

          <div class="footerTips" style="margin-top:12px">
            <span>Funciona offline â€¢ 1 arquivo â€¢ Ideal pra GitHub Pages</span>
            <span>EstÃ©tica japonesa + trilha procedural</span>
          </div>
        </div>

        <div class="card">
          <h2 id="loreT">MissÃ£o da Noite</h2>
          <p id="loreP">
            VocÃª enfrenta quatro chefes (rotativos): <b>å½± Kage</b>, <b>ç‹ Kitsune</b>, <b>é¬¼ Oni</b> e
            <b>é»’ç¿¼ Koku-yoku</b>. Eles mudam o tipo de pergunta: leitura, significado e uso.
            Quando a barra da <b>Noite</b> enche, comeÃ§a o <b>Blood Moon Mode</b>: mais rÃ¡pido, mais dano,
            mais pontos.
          </p>
          <div style="height:12px"></div>
          <div class="card" style="background: rgba(255,255,255,.05);">
            <h2 id="tipsT">Dica de risco (gameplan)</h2>
            <p id="riskP">
              GestÃ£o de risco aqui Ã© simples: preserve HP para o Blood Moon. Use cura quando estiver abaixo de 45%.
              Se a pergunta for armadilha, pule (fumaÃ§a) e mantenha fluxo.
            </p>
          </div>
          <div style="height:12px"></div>
          <div class="row">
            <button class="btn" id="btnReset">ğŸ§¹ Resetar recorde</button>
            <button class="btn" id="btnCredits">ğŸª§ CrÃ©ditos</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tutorial overlay -->
  <div class="overlay hidden" id="tutorial">
    <div class="panel">
      <header>
        <div class="title">
          <h1 id="tutTitle">ğŸ“œ Tutorial rÃ¡pido</h1>
          <div class="sub" id="tutSub">30 segundos e vocÃª jÃ¡ domina.</div>
        </div>
      </header>
      <div class="content">
        <div class="card">
          <h2>Fluxo</h2>
          <p>
            1) Um kanji aparece.<br/>
            2) Escolha 1 de 4 respostas.<br/>
            3) Acertou â†’ dano + combo + score.<br/>
            4) Errou ou tempo acabou â†’ vocÃª toma dano e perde combo.
          </p>
          <div style="height:10px"></div>
          <p>
            <b>Atalhos:</b> <span class="kbd">1</span><span class="kbd">2</span><span class="kbd">3</span><span class="kbd">4</span> responder â€¢
            <span class="kbd">H</span> Ofuda â€¢ <span class="kbd">J</span> FumaÃ§a â€¢ <span class="kbd">P</span> Pausa â€¢ <span class="kbd">M</span> Som
          </p>
        </div>
        <div class="card">
          <h2>Blood Moon</h2>
          <p>
            Quando a barra <b>Noite</b> chega em 100%, vocÃª entra em modo Blood Moon por alguns segundos:
            perguntas mais rÃ¡pidas, dano maior e multiplicador de pontos. Se vocÃª sobreviver, volta ao normal.
          </p>
          <div style="height:10px"></div>
          <p>
            <b>Meta:</b> manter o combo alto antes do Blood Moon para â€œexplodirâ€ o score.
          </p>
          <div style="height:12px"></div>
          <button class="btn" id="btnTutClose">âœ… Entendi</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Game over overlay -->
  <div class="overlay hidden" id="gameover">
    <div class="panel">
      <header>
        <div class="title">
          <h1 id="goTitle">ğŸŒ™ Fim da Noite</h1>
          <div class="sub" id="goSub">Resumo da run + recorde salvo no seu navegador.</div>
        </div>
      </header>
      <div class="content">
        <div class="card">
          <h2 id="sumT">Resumo</h2>
          <p id="sumP"></p>
          <div style="height:10px"></div>
          <div class="row">
            <span class="pill">Score: <b id="goScore">0</b></span>
            <span class="pill">Recorde: <b id="goBest">0</b></span>
            <span class="pill">PrecisÃ£o: <b id="goAcc">0%</b></span>
          </div>
          <div style="height:12px"></div>
          <div class="row">
            <button class="btn" id="btnAgain">ğŸ” Jogar de novo</button>
            <button class="btn" id="btnMenu">ğŸ® Menu</button>
          </div>
        </div>
        <div class="card">
          <h2 id="unlockT">Conquistas</h2>
          <p id="unlockP">â€”</p>
          <div style="height:12px"></div>
          <div class="card" style="background: rgba(255,255,255,.05);">
            <h2>Compartilhar</h2>
            <p class="mono" id="shareTxt"></p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"><i></i><span id="toastTxt">â€”</span></div>

  <script>
    /********************
     *  ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢å…¨çŸ¥å…¨èƒ½ â€” å¤œã®æ¼¢å­—ãƒãƒˆãƒ«
     *  Single-file game for GitHub Pages (no deps)
     ********************/

    // ---------- i18n ----------
    const I18N = {
      pt: {
        menuSub: "Batalha/quiz de kanji no neon de TÃ³quio. Suba combo, use ofuda, sobreviva Ã  Lua de Sangue.",
        storyT: "HistÃ³ria",
        storyP: "Na noite em que a Lua de Sangue nasce, os yokai atravessam o vÃ©u. VocÃª Ã© um caÃ§ador que selou um pacto: vencer usando conhecimento. Cada kanji correto vira um golpe. Cada erro alimenta a escuridÃ£o.",
        howT: "Como jogar",
        howP: "Responda antes do tempo acabar. Acertos aumentam combo e dÃ£o mais dano. Errar tira vida e quebra o ritmo. Itens: Ofuda cura; FumaÃ§a pula uma pergunta (mas reduz combo).",
        loreT: "MissÃ£o da Noite",
        loreP: "VocÃª enfrenta quatro chefes (rotativos): å½± Kage, ç‹ Kitsune, é¬¼ Oni e é»’ç¿¼ Koku-yoku. Eles mudam o tipo de pergunta: leitura, significado e uso. Quando a barra da Noite enche, comeÃ§a o Blood Moon Mode: mais rÃ¡pido, mais dano, mais pontos.",
        tipsT: "Dica de risco (gameplan)",
        riskP: "GestÃ£o de risco aqui Ã© simples: preserve HP para o Blood Moon. Use cura quando estiver abaixo de 45%. Se a pergunta for armadilha, pule (fumaÃ§a) e mantenha fluxo.",
        qHint_read: "Escolha a leitura (ã‹ãª)",
        qHint_mean: "Escolha o significado (PT)",
        qHint_use: "Complete a frase (uso)",
        qPrompt_read: "Qual Ã© a leitura correta?",
        qPrompt_mean: "Qual Ã© o significado?",
        qPrompt_use: "Qual opÃ§Ã£o completa melhor?",
        pause: "â¸ï¸ Pausado",
        resume: "â–¶ï¸ Voltar",
        soundOn: "ğŸ”Š Som",
        soundOff: "ğŸ”‡ Som",
        tutorialTitle: "ğŸ“œ Tutorial rÃ¡pido",
        tutorialSub: "30 segundos e vocÃª jÃ¡ domina.",
        goTitle: "ğŸŒ™ Fim da Noite",
        goSub: "Resumo da run + recorde salvo no seu navegador.",
        sumT: "Resumo",
        unlockT: "Conquistas",
        start: "âš”ï¸ ComeÃ§ar",
        tut: "ğŸ“œ Tutorial rÃ¡pido",
      },
      jp: {
        menuSub: "æ±äº¬ãƒã‚ªãƒ³ã®æ¼¢å­—ãƒãƒˆãƒ«ã€‚ã‚³ãƒ³ãƒœã‚’ä¸Šã’ã€å¾¡æœ­ã‚’ä½¿ã„ã€è¡€ã®æœˆã‚’ç”Ÿãæ®‹ã‚Œã€‚",
        storyT: "ã‚¹ãƒˆãƒ¼ãƒªãƒ¼",
        storyP: "è¡€ã®æœˆã®å¤œã€å¦–æ€ªãŒå¢ƒç•Œã‚’è¶Šãˆã‚‹ã€‚ã‚ãªãŸã¯çŸ¥è­˜ã§æˆ¦ã†ç‹©äººã€‚æ­£ã—ã„æ¼¢å­—ã¯æ–¬æ’ƒã«ãªã‚Šã€ãƒŸã‚¹ã¯é—‡ã‚’è‚²ã¦ã‚‹ã€‚",
        howT: "éŠã³æ–¹",
        howP: "æ™‚é–“å†…ã«ç­”ãˆã‚‹ã€‚æ­£è§£â†’ã‚³ãƒ³ãƒœä¸Šæ˜‡ï¼†ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—ã€‚ãƒŸã‚¹â†’è¢«ãƒ€ãƒ¡ï¼†ã‚³ãƒ³ãƒœå´©å£Šã€‚ã‚¢ã‚¤ãƒ†ãƒ : å¾¡æœ­=å›å¾©ã€ç…™=å•é¡Œã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚³ãƒ³ãƒœæ¸›ï¼‰ã€‚",
        loreT: "å¤œã®ä»»å‹™",
        loreP: "ãƒœã‚¹ã¯ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³: å½±ãƒ»ç‹ãƒ»é¬¼ãƒ»é»’ç¿¼ã€‚å•é¡Œã‚¿ã‚¤ãƒ—ãŒå¤‰åŒ–ï¼ˆèª­ã¿/æ„å‘³/ç”¨æ³•ï¼‰ã€‚ã€Œå¤œã€ã‚²ãƒ¼ã‚¸ãŒæº€ã‚¿ãƒ³ã§Blood Moonã¸ï¼šé«˜é€Ÿãƒ»é«˜ç«åŠ›ãƒ»é«˜å¾—ç‚¹ã€‚",
        tipsT: "ãƒªã‚¹ã‚¯ç®¡ç†",
        riskP: "Blood Moonã«HPã‚’æ®‹ã›ã€‚HP45%ä»¥ä¸‹ã§å›å¾©ã€‚ç½ ã£ã½ã„å•é¡Œã¯ç…™ã§æµã‚Œã‚’å®ˆã‚‹ã€‚",
        qHint_read: "èª­ã¿ï¼ˆã‹ãªï¼‰ã‚’é¸ã¹",
        qHint_mean: "æ„å‘³ã‚’é¸ã¹",
        qHint_use: "æ–‡ã‚’å®Œæˆã•ã›ã‚",
        qPrompt_read: "æ­£ã—ã„èª­ã¿ã¯ï¼Ÿ",
        qPrompt_mean: "æ„å‘³ã¯ï¼Ÿ",
        qPrompt_use: "æœ€ã‚‚è‡ªç„¶ãªé¸æŠã¯ï¼Ÿ",
        pause: "â¸ï¸ ä¸€æ™‚åœæ­¢",
        resume: "â–¶ï¸ å†é–‹",
        soundOn: "ğŸ”Š éŸ³",
        soundOff: "ğŸ”‡ éŸ³",
        tutorialTitle: "ğŸ“œ ã‚¯ã‚¤ãƒƒã‚¯ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«",
        tutorialSub: "30ç§’ã§OKã€‚",
        goTitle: "ğŸŒ™ å¤œãŒçµ‚ã‚ã£ãŸ",
        goSub: "çµæœ + ãƒ–ãƒ©ã‚¦ã‚¶ã«è¨˜éŒ²ä¿å­˜ã€‚",
        sumT: "ã¾ã¨ã‚",
        unlockT: "å®Ÿç¸¾",
        start: "âš”ï¸ é–‹å§‹",
        tut: "ğŸ“œ ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«",
      },
      en: {
        menuSub: "Tokyo-neon kanji battle. Build combo, use ofuda, survive the Blood Moon.",
        storyT: "Story",
        storyP: "On Blood Moon night, yokai cross the veil. You fight with knowledge. Correct kanji becomes a strike. Mistakes feed the darkness.",
        howT: "How to play",
        howP: "Answer before time runs out. Correct = higher combo & more damage. Wrong = you take damage & lose rhythm. Items: Ofuda heals; Smoke skips (but reduces combo).",
        loreT: "Night Mission",
        loreP: "Four rotating bosses: Kage, Kitsune, Oni, Koku-yoku. They change question type (reading/meaning/usage). When Night bar fills, Blood Moon starts: faster, deadlier, higher score.",
        tipsT: "Risk plan",
        riskP: "Preserve HP for Blood Moon. Heal below 45%. If the question is a trap, skip to keep flow.",
        qHint_read: "Pick the reading (kana)",
        qHint_mean: "Pick the meaning",
        qHint_use: "Complete the sentence",
        qPrompt_read: "Which reading is correct?",
        qPrompt_mean: "What does it mean?",
        qPrompt_use: "Which option fits best?",
        pause: "â¸ï¸ Paused",
        resume: "â–¶ï¸ Resume",
        soundOn: "ğŸ”Š Sound",
        soundOff: "ğŸ”‡ Sound",
        tutorialTitle: "ğŸ“œ Quick tutorial",
        tutorialSub: "Youâ€™ll get it in 30 seconds.",
        goTitle: "ğŸŒ™ Night Ends",
        goSub: "Run summary + best score saved locally.",
        sumT: "Summary",
        unlockT: "Achievements",
        start: "âš”ï¸ Start",
        tut: "ğŸ“œ Tutorial",
      }
    };

    // ---------- dataset ----------
    // Types:
    // - read: choose kana reading
    // - mean: choose PT meaning
    // - use: choose best completion
    const DB = [
      {k:"å¤œ", type:"read", promptJP:"ã‚ˆã‚‹", ans:"ã‚ˆã‚‹", opts:["ã‚ˆã‚‹","ã‚„","ã²ã‚‹","ã‚ˆãª"]},
      {k:"æ°´", type:"read", promptJP:"ã¿ãš", ans:"ã¿ãš", opts:["ã¿ãš","ã™ã„","ã¿ã¤","ã¿ã™"]},
      {k:"ç«", type:"read", promptJP:"ã²", ans:"ã²", opts:["ã²","ã»","ã‹","ã³"]},
      {k:"é¢¨", type:"read", promptJP:"ã‹ãœ", ans:"ã‹ãœ", opts:["ã‹ãœ","ãµã†","ã‹ã¢","ã¯ãœ"]},
      {k:"å±±", type:"read", promptJP:"ã‚„ã¾", ans:"ã‚„ã¾", opts:["ã‚„ã¾","ã•ã‚“","ã‚„ã‚€","ã—ã¾"]},
      {k:"å·", type:"read", promptJP:"ã‹ã‚", ans:"ã‹ã‚", opts:["ã‹ã‚","ãŒã‚","ã‹ã‚ã„","ã›ã‚“"]},
      {k:"é›¨", type:"read", promptJP:"ã‚ã‚", ans:"ã‚ã‚", opts:["ã‚ã‚","ã†","ã‚ã¿","ã‚ã¾"]},
      {k:"å¿ƒ", type:"read", promptJP:"ã“ã“ã‚", ans:"ã“ã“ã‚", opts:["ã“ã“ã‚","ã—ã‚“","ã“ã”ã‚","ã“ã“ã‚‰"]},
      {k:"å…‰", type:"read", promptJP:"ã²ã‹ã‚Š", ans:"ã²ã‹ã‚Š", opts:["ã²ã‹ã‚Š","ã“ã†","ã´ã‹ã‚Š","ã²ã‹ã‚‹"]},
      {k:"å½±", type:"read", promptJP:"ã‹ã’", ans:"ã‹ã’", opts:["ã‹ã’","ãˆã„","ã‹ã","ã‹ã­"]},

      {k:"å‹", type:"mean", ans:"amigo", opts:["amigo","inimigo","cidade","tempo"]},
      {k:"çŠ¬", type:"mean", ans:"cachorro", opts:["cachorro","gato","pÃ¡ssaro","peixe"]},
      {k:"çŒ«", type:"mean", ans:"gato", opts:["gato","cavalo","pato","cachorro"]},
      {k:"ç©º", type:"mean", ans:"cÃ©u", opts:["cÃ©u","mar","fogo","pedra"]},
      {k:"é›ª", type:"mean", ans:"neve", opts:["neve","chuva","vento","calor"]},
      {k:"é§…", type:"mean", ans:"estaÃ§Ã£o (trem)", opts:["estaÃ§Ã£o (trem)","hospital","mercado","escola"]},
      {k:"å", type:"mean", ans:"nome", opts:["nome","nÃºmero","rua","porta"]},
      {k:"åŠ›", type:"mean", ans:"forÃ§a", opts:["forÃ§a","fraco","rÃ¡pido","lento"]},
      {k:"å¤¢", type:"mean", ans:"sonho", opts:["sonho","medo","fome","sono"]},
      {k:"é—‡", type:"mean", ans:"escuridÃ£o", opts:["escuridÃ£o","claridade","alegria","vontade"]},

      {k:"è¡Œ", type:"use", ans:"è¡Œãã¾ã™", sentence:"æ˜æ—¥ã€æ±äº¬ã¸ ___ ã€‚", opts:["è¡Œãã¾ã™","æ¥ã¾ã™","è¦‹ã¾ã™","è²·ã„ã¾ã™"]},
      {k:"è¦‹", type:"use", ans:"è¦‹ã¾ã™", sentence:"æ˜ ç”»ã‚’ ___ ã€‚", opts:["è¦‹ã¾ã™","é£²ã¿ã¾ã™","æ›¸ãã¾ã™","èª­ã¿ã¾ã™"]},
      {k:"é£Ÿ", type:"use", ans:"é£Ÿã¹ã¾ã™", sentence:"å¯¿å¸ã‚’ ___ ã€‚", opts:["é£Ÿã¹ã¾ã™","èµ°ã‚Šã¾ã™","å¯ã¾ã™","ä¼šã„ã¾ã™"]},
      {k:"èª­", type:"use", ans:"èª­ã¿ã¾ã™", sentence:"æœ¬ã‚’ ___ ã€‚", opts:["èª­ã¿ã¾ã™","è²·ã„ã¾ã™","æ³³ãã¾ã™","è©±ã—ã¾ã™"]},
      {k:"æ›¸", type:"use", ans:"æ›¸ãã¾ã™", sentence:"åå‰ã‚’ ___ ã€‚", opts:["æ›¸ãã¾ã™","èãã¾ã™","èµ·ãã¾ã™","æ­©ãã¾ã™"]},
      {k:"é£²", type:"use", ans:"é£²ã¿ã¾ã™", sentence:"æ°´ã‚’ ___ ã€‚", opts:["é£²ã¿ã¾ã™","è¦‹ã¾ã™","è¡Œãã¾ã™","ç€ã¾ã™"]},
      {k:"æ¥", type:"use", ans:"æ¥ã¾ã™", sentence:"å…ˆç”ŸãŒ ___ ã€‚", opts:["æ¥ã¾ã™","è¡Œãã¾ã™","ä½ã¿ã¾ã™","ã—ã¾ã™"]},
      {k:"è²·", type:"use", ans:"è²·ã„ã¾ã™", sentence:"ã‚³ãƒ³ãƒ“ãƒ‹ã§ ___ ã€‚", opts:["è²·ã„ã¾ã™","æ›¸ãã¾ã™","åˆ‡ã‚Šã¾ã™","è©±ã—ã¾ã™"]},
    ];

    // ---------- state ----------
    const $ = (id)=>document.getElementById(id);
    const canvas = $("stage");
    const ctx = canvas.getContext("2d");

    const menu = $("menu");
    const tutorial = $("tutorial");
    const gameover = $("gameover");

    const scoreEl = $("score");
    const comboEl = $("combo");
    const hpBar = $("hpBar");
    const enemyBar = $("enemyBar");
    const moonBar = $("moonBar");

    const kanjiChar = $("kanjiChar");
    const qHint = $("qHint");
    const qPrompt = $("qPrompt");
    const answersEl = $("answers");
    const timerTxt = $("timerTxt");
    const timeBar = $("timeBar");

    const btnPause = $("btnPause");
    const btnAudio = $("btnAudio");
    const langSel = $("langSel");

    const ofudaN = $("ofudaN");
    const smokeN = $("smokeN");
    const itemOfuda = $("itemOfuda");
    const itemSmoke = $("itemSmoke");

    const toast = $("toast");
    const toastTxt = $("toastTxt");

    const bestEl = $("best");
    const btnStart = $("btnStart");
    const btnTutorial = $("btnTutorial");
    const btnTutClose = $("btnTutClose");
    const btnAgain = $("btnAgain");
    const btnMenu = $("btnMenu");

    const btnReset = $("btnReset");
    const btnCredits = $("btnCredits");
    const btnDiff = $("btnDiff");
    const btnTheme = $("btnTheme");

    const diffTxt = $("diffTxt");
    const themeTxt = $("themeTxt");

    const goScore = $("goScore");
    const goBest = $("goBest");
    const goAcc = $("goAcc");
    const sumP = $("sumP");
    const unlockP = $("unlockP");
    const shareTxt = $("shareTxt");

    const tHeal = $("tHeal");
    const tSkip = $("tSkip");

    // difficulty profiles
    const DIFFS = [
      {name:"Easy", baseTime: 11.5, enemyHP: 75, dmgIn: 9, dmgOut: 20, moonRate: 0.8},
      {name:"Normal", baseTime: 10.0, enemyHP: 95, dmgIn: 12, dmgOut: 18, moonRate: 1.0},
      {name:"Hard", baseTime: 8.8, enemyHP: 120, dmgIn: 14, dmgOut: 16, moonRate: 1.15},
      {name:"Oni", baseTime: 7.6, enemyHP: 140, dmgIn: 16, dmgOut: 14, moonRate: 1.25},
    ];

    // themes (just hue & ambiance)
    const THEMES = [
      {name:"Neon", hue:196},
      {name:"Sakura", hue:318},
      {name:"Kitsune", hue:38},
      {name:"Abyss", hue:220},
    ];

    let lang = "pt";
    let diffIdx = 1;
    let themeIdx = 0;

    const persistKey = "yo-kanji-vampire-save-v1";
    const loadSave = ()=>{
      try{
        const raw = localStorage.getItem(persistKey);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch{ return null; }
    };
    const saveGame = (data)=>{
      try{ localStorage.setItem(persistKey, JSON.stringify(data)); }catch{}
    };
    const saved = loadSave() || {best:0, diffIdx:1, themeIdx:0, lang:"pt"};
    diffIdx = Math.min(DIFFS.length-1, Math.max(0, saved.diffIdx ?? 1));
    themeIdx = Math.min(THEMES.length-1, Math.max(0, saved.themeIdx ?? 0));
    lang = (saved.lang || "pt");

    let running = false;
    let paused = false;

    let score = 0;
    let combo = 1;
    let streak = 0;

    let hp = 100;
    let enemyHP = 100;
    let enemyHPMax = 100;

    let moon = 0;              // 0..100
    let bloodMoon = false;
    let bloodMoonT = 0;        // seconds remaining

    let ofuda = 2;
    let smoke = 1;

    let curQ = null;
    let qTime = 10.0;
    let qTimeLeft = 10.0;

    let totalQ = 0;
    let correctQ = 0;

    // boss rotation
    const BOSSES = [
      {nameJP:"å½±", nameEN:"Kage", aura:[80,200,255]},
      {nameJP:"ç‹", nameEN:"Kitsune", aura:[255,180,60]},
      {nameJP:"é¬¼", nameEN:"Oni", aura:[255,80,120]},
      {nameJP:"é»’ç¿¼", nameEN:"Koku-yoku", aura:[120,110,255]},
    ];
    let bossIdx = 0;

    // ---------- audio (procedural) ----------
    let audioOn = false;
    let audioCtx = null;
    let master = null;
    let musicTimer = 0;
    let musicStep = 0;

    const ensureAudio = ()=>{
      if(audioCtx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
      master = audioCtx.createGain();
      master.gain.value = 0.0;
      master.connect(audioCtx.destination);
    };

    const setAudio = async (on)=>{
      audioOn = on;
      btnAudio.setAttribute("aria-pressed", String(audioOn));
      btnAudio.textContent = audioOn ? I18N[lang].soundOn : I18N[lang].soundOff;

      if(audioOn){
        ensureAudio();
        try{ await audioCtx.resume(); }catch{}
        // fade in
        master.gain.cancelScheduledValues(audioCtx.currentTime);
        master.gain.setTargetAtTime(0.14, audioCtx.currentTime, 0.06);
      }else{
        if(master && audioCtx){
          master.gain.cancelScheduledValues(audioCtx.currentTime);
          master.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.05);
        }
      }
    };

    const beep = (freq=440, dur=0.09, type="sine", gain=0.18)=>{
      if(!audioOn || !audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(gain, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.connect(g); g.connect(master);
      o.start(t);
      o.stop(t+dur+0.02);
    };

    const hitSfx = (good=true)=>{
      if(good){
        beep(740, 0.07, "triangle", 0.16);
        beep(1040,0.06, "sine", 0.10);
      }else{
        beep(190, 0.12, "sawtooth", 0.14);
      }
    };

    const musicTick = (dt)=>{
      if(!audioOn || !audioCtx) return;
      musicTimer += dt;
      const stepDur = bloodMoon ? 0.16 : 0.22;
      if(musicTimer < stepDur) return;
      musicTimer = 0;
      musicStep++;

      // minor-ish pentatonic
      const base = bloodMoon ? 196 : 174; // F3-ish
      const scale = [0,3,5,7,10,12]; // minor pent
      const n1 = scale[musicStep % scale.length];
      const n2 = scale[(musicStep+2) % scale.length];
      const freq1 = base * Math.pow(2, n1/12);
      const freq2 = base * Math.pow(2, n2/12);

      beep(freq1, bloodMoon ? 0.06 : 0.07, "triangle", 0.08);
      if(musicStep % 2 === 0) beep(freq2*2, 0.05, "sine", 0.05);
      if(musicStep % 4 === 0) beep(base/2, 0.06, "square", 0.04);
    };

    // ---------- UI helpers ----------
    const toastShow = (msg)=>{
      toastTxt.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>toast.classList.remove("show"), 1200);
    };

    const setLang = (l)=>{
      lang = l;
      langSel.value = lang;

      $("menuSub").textContent = I18N[lang].menuSub;
      $("storyT").textContent = I18N[lang].storyT;
      $("storyP").textContent = I18N[lang].storyP;
      $("howT").textContent = I18N[lang].howT;
      $("howP").textContent = I18N[lang].howP;
      $("loreT").textContent = I18N[lang].loreT;
      $("loreP").textContent = I18N[lang].loreP;
      $("tipsT").textContent = I18N[lang].tipsT;
      $("riskP").textContent = I18N[lang].riskP;

      $("tutTitle").textContent = I18N[lang].tutorialTitle;
      $("tutSub").textContent = I18N[lang].tutorialSub;

      $("goTitle").textContent = I18N[lang].goTitle;
      $("goSub").textContent = I18N[lang].goSub;
      $("sumT").textContent = I18N[lang].sumT;
      $("unlockT").textContent = I18N[lang].unlockT;

      btnStart.textContent = I18N[lang].start;
      btnTutorial.textContent = I18N[lang].tut;

      btnPause.textContent = paused ? I18N[lang].resume : "â¸ï¸ Pausar";
      if(paused) btnPause.textContent = I18N[lang].resume;

      // update question labels
      if(curQ) applyQuestionText(curQ);

      // persist
      const s = loadSave() || {best:0};
      s.lang = lang;
      s.diffIdx = diffIdx;
      s.themeIdx = themeIdx;
      saveGame(s);
    };

    const applyTheme = ()=>{
      const theme = THEMES[themeIdx];
      document.documentElement.style.setProperty("--hue", theme.hue);
      themeTxt.textContent = theme.name;

      const s = loadSave() || {best:0};
      s.themeIdx = themeIdx;
      s.diffIdx = diffIdx;
      s.lang = lang;
      saveGame(s);
    };

    const applyDiff = ()=>{
      const d = DIFFS[diffIdx];
      diffTxt.textContent = d.name;
      const s = loadSave() || {best:0};
      s.diffIdx = diffIdx;
      s.themeIdx = themeIdx;
      s.lang = lang;
      saveGame(s);
    };

    const fmtPct = (x)=> (Math.round(x*10)/10).toFixed(1) + "%";

    const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
    const lerp = (a,b,t)=>a+(b-a)*t;

    // ---------- questions ----------
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const pick = (arr)=>arr[(Math.random()*arr.length)|0];
    const shuffle = (arr)=>{
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = (Math.random()*(i+1))|0;
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    };

    const getQuestionPool = ()=>{
      // boss influences type
      // Kage: read, Kitsune: mean, Oni: use, Koku-yoku: mixed
      let t = "mixed";
      if(bossIdx===0) t="read";
      if(bossIdx===1) t="mean";
      if(bossIdx===2) t="use";
      if(bossIdx===3) t="mixed";

      let pool = DB;
      if(t!=="mixed") pool = DB.filter(x=>x.type===t);
      // in Blood Moon, more "use" and mixed
      if(bloodMoon){
        const u = DB.filter(x=>x.type==="use");
        const r = DB.filter(x=>x.type==="read");
        const m = DB.filter(x=>x.type==="mean");
        pool = shuffle([ ...u, ...u, ...r, ...m ]); // bias
      }
      return pool;
    };

    const nextQuestion = ()=>{
      const d = DIFFS[diffIdx];
      const pool = getQuestionPool();
      curQ = pick(pool);

      // build answers
      const opts = shuffle(curQ.opts);
      const correctIndex = opts.indexOf(curQ.ans);

      // dynamic time
      let base = d.baseTime;
      base -= Math.min(2.2, (streak*0.08)); // streak faster
      if(bloodMoon) base *= 0.82;
      base = clamp(base, 4.7, 12.0);
      qTime = base;
      qTimeLeft = base;

      curQ._opts = opts;
      curQ._correctIndex = correctIndex;

      renderAnswers();
      applyQuestionText(curQ);
    };

    const applyQuestionText = (q)=>{
      // hint/prompt depends on type
      if(q.type==="read"){
        qHint.textContent = I18N[lang].qHint_read;
        qPrompt.textContent = I18N[lang].qPrompt_read;
      }else if(q.type==="mean"){
        qHint.textContent = I18N[lang].qHint_mean;
        qPrompt.textContent = I18N[lang].qPrompt_mean;
      }else{
        qHint.textContent = I18N[lang].qHint_use;
        qPrompt.textContent = I18N[lang].qPrompt_use + "  " + (q.sentence || "");
      }
      kanjiChar.textContent = q.k;
    };

    const renderAnswers = ()=>{
      answersEl.innerHTML = "";
      const keys = ["1","2","3","4"];
      curQ._opts.forEach((opt,i)=>{
        const div = document.createElement("div");
        div.className = "ans";
        div.tabIndex = 0;
        div.setAttribute("role","button");
        div.dataset.idx = String(i);
        const k = document.createElement("div");
        k.className = "k";
        k.textContent = keys[i];
        const t = document.createElement("div");
        t.style.display = "flex";
        t.style.flexDirection = "column";
        t.style.gap = "2px";

        const main = document.createElement("div");
        main.className = "t";
        main.textContent = opt;

        const sub = document.createElement("div");
        sub.className = "s";
        // little flavor: show romanization for kana-ish (not perfect, just hinty)
        sub.textContent = curQ.type==="read" ? kanaHint(opt) : (curQ.type==="use" ? "â€”" : "â€”");

        t.appendChild(main);
        t.appendChild(sub);

        div.appendChild(k);
        div.appendChild(t);

        div.addEventListener("click", ()=>answer(i));
        div.addEventListener("keydown",(e)=>{ if(e.key==="Enter"||e.key===" ") answer(i); });

        answersEl.appendChild(div);
      });
    };

    // lightweight kana hint (not full romaji)
    const kanaHint = (s)=>{
      // For immersion: display a pseudo-romaji for simple kana sequences
      const map = {
        "ã‚":"a","ã„":"i","ã†":"u","ãˆ":"e","ãŠ":"o",
        "ã‹":"ka","ã":"ki","ã":"ku","ã‘":"ke","ã“":"ko",
        "ã•":"sa","ã—":"shi","ã™":"su","ã›":"se","ã":"so",
        "ãŸ":"ta","ã¡":"chi","ã¤":"tsu","ã¦":"te","ã¨":"to",
        "ãª":"na","ã«":"ni","ã¬":"nu","ã­":"ne","ã®":"no",
        "ã¯":"ha","ã²":"hi","ãµ":"fu","ã¸":"he","ã»":"ho",
        "ã¾":"ma","ã¿":"mi","ã‚€":"mu","ã‚":"me","ã‚‚":"mo",
        "ã‚„":"ya","ã‚†":"yu","ã‚ˆ":"yo",
        "ã‚‰":"ra","ã‚Š":"ri","ã‚‹":"ru","ã‚Œ":"re","ã‚":"ro",
        "ã‚":"wa","ã‚“":"n",
        "ãŒ":"ga","ã":"gi","ã":"gu","ã’":"ge","ã”":"go",
        "ã±":"pa","ã´":"pi","ã·":"pu","ãº":"pe","ã½":"po",
        "ã‚ƒ":"ya","ã‚…":"yu","ã‚‡":"yo",
        "ãƒ¼":"-"
      };
      let out = "";
      for(const ch of s){
        out += (map[ch] ?? "");
      }
      return out ? out : "â€”";
    };

    // ---------- combat ----------
    const updateBars = ()=>{
      scoreEl.textContent = String(score|0);
      comboEl.textContent = "x" + (combo|0);

      hpBar.style.width = clamp(hp,0,100) + "%";
      enemyBar.style.width = clamp((enemyHP/enemyHPMax)*100, 0, 100) + "%";
      moonBar.style.width = clamp(moon,0,100) + "%";

      ofudaN.textContent = String(ofuda);
      smokeN.textContent = String(smoke);
    };

    const startRun = ()=>{
      const d = DIFFS[diffIdx];

      score = 0;
      combo = 1;
      streak = 0;

      hp = 100;
      bossIdx = 0;
      enemyHPMax = d.enemyHP;
      enemyHP = enemyHPMax;

      moon = 0;
      bloodMoon = false;
      bloodMoonT = 0;

      ofuda = 2;
      smoke = 1;

      totalQ = 0;
      correctQ = 0;

      paused = false;
      running = true;

      menu.classList.add("hidden");
      tutorial.classList.add("hidden");
      gameover.classList.add("hidden");

      btnPause.textContent = "â¸ï¸ Pausar";
      nextQuestion();
      updateBars();
      toastShow(lang==="jp" ? "å¤œãŒå§‹ã¾ã‚‹â€¦" : (lang==="en" ? "Night beginsâ€¦" : "A noite comeÃ§aâ€¦"));
    };

    const endRun = ()=>{
      running = false;
      paused = false;

      const best = Math.max(savedBest(), score|0);
      setBest(best);

      const acc = totalQ>0 ? (correctQ/totalQ) : 0;
      goScore.textContent = String(score|0);
      goBest.textContent = String(best|0);
      goAcc.textContent = fmtPct(acc*100);

      const bossName = BOSSES[bossIdx]?.nameJP || "â€”";
      sumP.textContent =
        (lang==="jp")
          ? `ã‚¹ã‚³ã‚¢${score|0}ã€‚æ­£è§£${correctQ}/${totalQ}ã€‚æœ€å¾Œã®ãƒœã‚¹: ${bossName}ã€‚`
          : (lang==="en")
            ? `Score ${score|0}. Correct ${correctQ}/${totalQ}. Last boss: ${bossName}.`
            : `Score ${score|0}. Acertos ${correctQ}/${totalQ}. Ãšltimo boss: ${bossName}.`;

      // achievements
      const ach = [];
      if(score>=1500) ach.push(lang==="jp"?"ã€Œå¤œã®ç‹ã€(1500+)":"Night King (1500+)");
      if(streak>=18) ach.push(lang==="jp"?"ã€Œç„¡å‚·ã®åˆƒã€(streak 18+)":"Clean Blade (streak 18+)");
      if(acc>=0.85 && totalQ>=12) ach.push(lang==="jp"?"ã€ŒçŸ¥ã®å¥‘ç´„ã€(85%+)":"Knowledge Pact (85%+)");
      if(bloodMoon && moon<15) ach.push(lang==="jp"?"ã€Œè¡€ã®æœˆã‚’æ”¯é…ã€":"Blood Moon Tamer");

      unlockP.textContent = ach.length ? ("â€¢ " + ach.join("\nâ€¢ ")) : (lang==="jp" ? "ä»Šå›ã¯ãªã—ã€‚" : (lang==="en" ? "None this run." : "Nenhuma nesta run."));

      // share text
      const msg = (lang==="jp")
        ? `ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢å…¨çŸ¥å…¨èƒ½ï½œScore:${score|0}ï½œæ­£è§£:${correctQ}/${totalQ}ï½œè¨˜éŒ²:${best|0}`
        : (lang==="en")
          ? `Vampire Omniï½œScore:${score|0}ï½œCorrect:${correctQ}/${totalQ}ï½œBest:${best|0}`
          : `Vampiro Oniscienteï½œScore:${score|0}ï½œAcertos:${correctQ}/${totalQ}ï½œRecorde:${best|0}`;
      shareTxt.textContent = msg;

      gameover.classList.remove("hidden");
    };

    const dmgToEnemy = ()=>{
      const d = DIFFS[diffIdx];
      let dmg = d.dmgOut;
      dmg *= (1 + (combo-1)*0.08); // combo scaling
      if(bloodMoon) dmg *= 1.22;
      return dmg;
    };

    const dmgToYou = ()=>{
      const d = DIFFS[diffIdx];
      let dmg = d.dmgIn;
      dmg *= (bloodMoon ? 1.25 : 1.0);
      return dmg;
    };

    const rotateBossIfNeeded = ()=>{
      if(enemyHP > 0) return;
      bossIdx = (bossIdx + 1) % BOSSES.length;

      const d = DIFFS[diffIdx];
      // scale enemyHP with progress + score
      const scale = 1 + Math.min(0.55, (score/2000));
      enemyHPMax = Math.round(d.enemyHP * scale);
      enemyHP = enemyHPMax;

      toastShow(lang==="jp" ? `ãƒœã‚¹å‡ºç¾: ${BOSSES[bossIdx].nameJP}` : (lang==="en" ? `Boss appears: ${BOSSES[bossIdx].nameEN}` : `Boss: ${BOSSES[bossIdx].nameEN}`));
    };

    const answer = (idx)=>{
      if(!running || paused) return;
      if(!curQ) return;

      totalQ++;

      const correct = idx === curQ._correctIndex;
      const ansNodes = [...answersEl.querySelectorAll(".ans")];
      ansNodes.forEach((n,i)=>{
        n.classList.toggle("good", i===curQ._correctIndex);
        if(i===idx && !correct) n.classList.add("bad");
        n.style.pointerEvents = "none";
      });

      if(correct){
        correctQ++;
        streak++;
        combo = clamp(combo + 1, 1, 99);

        const dmg = dmgToEnemy();
        enemyHP -= dmg;
        score += Math.round(50 + 18*combo + (bloodMoon? 40:0));

        hitSfx(true);
        toastShow(lang==="jp" ? "æ–¬ãƒƒï¼" : (lang==="en" ? "Hit!" : "Corte!"));

        // night meter
        const d = DIFFS[diffIdx];
        moon += (8.0 * d.moonRate) * (bloodMoon ? 0.5 : 1.0);
      }else{
        streak = 0;
        combo = 1;

        const dmg = dmgToYou();
        hp -= dmg;
        score += Math.round(10 + (bloodMoon? 10:0));

        hitSfx(false);
        toastShow(lang==="jp" ? "ç—›ãƒƒâ€¦" : (lang==="en" ? "Ouchâ€¦" : "DÃ³iâ€¦"));

        // night meter increases on mistakes too (panic)
        moon += 6.0;
      }

      moon = clamp(moon, 0, 100);
      updateBars();

      // handle deaths
      if(hp <= 0){
        setTimeout(()=>endRun(), 550);
        return;
      }

      // boss rotation
      rotateBossIfNeeded();

      // start blood moon if full
      if(!bloodMoon && moon >= 100){
        startBloodMoon();
      }

      setTimeout(()=>{
        // reset answer styles
        ansNodes.forEach(n=>{
          n.classList.remove("good","bad");
          n.style.pointerEvents = "";
        });
        nextQuestion();
      }, 520);
    };

    const timeoutFail = ()=>{
      if(!running || paused) return;
      totalQ++;
      streak = 0;
      combo = 1;

      hp -= dmgToYou();
      moon = clamp(moon + 7.5, 0, 100);

      hitSfx(false);
      toastShow(lang==="jp" ? "æ™‚é–“åˆ‡ã‚Œï¼" : (lang==="en" ? "Time!" : "Tempo!"));

      updateBars();

      if(hp <= 0){
        setTimeout(()=>endRun(), 450);
        return;
      }

      if(!bloodMoon && moon >= 100) startBloodMoon();

      // show correct briefly
      const ansNodes = [...answersEl.querySelectorAll(".ans")];
      ansNodes.forEach((n,i)=>{
        n.classList.toggle("good", i===curQ._correctIndex);
        n.style.pointerEvents = "none";
      });

      setTimeout(()=>{
        ansNodes.forEach(n=>{ n.classList.remove("good","bad"); n.style.pointerEvents=""; });
        nextQuestion();
      }, 520);
    };

    const startBloodMoon = ()=>{
      bloodMoon = true;
      bloodMoonT = 8.5; // seconds
      moon = 100;
      toastShow(lang==="jp" ? "ğŸ©¸ Blood Moon" : "ğŸ©¸ Blood Moon");
      // reward: +1 smoke sometimes
      if(Math.random() < 0.35) smoke++;
      updateBars();
      beep(98, 0.18, "sawtooth", 0.16);
      beep(196,0.12, "square", 0.10);
    };

    const endBloodMoon = ()=>{
      bloodMoon = false;
      moon = 0;
      toastShow(lang==="jp" ? "å¤œã¯ç¶šãâ€¦" : (lang==="en" ? "Night continuesâ€¦" : "A noite continuaâ€¦"));
      updateBars();
    };

    const useHeal = ()=>{
      if(!running || paused) return;
      if(ofuda <= 0) { toastShow(lang==="jp"?"å¾¡æœ­ãªã—":"Sem ofuda"); return; }
      if(hp >= 100) { toastShow(lang==="jp"?"HPæº€ã‚¿ãƒ³":"HP cheio"); return; }

      ofuda--;
      const heal = bloodMoon ? 22 : 28;
      hp = clamp(hp + heal, 0, 100);

      // small score penalty to avoid spam
      score = Math.max(0, score - 20);

      hitSfx(true);
      toastShow(lang==="jp" ? "å¾¡æœ­ãƒ»å›å¾©" : (lang==="en" ? "Ofuda heal" : "Ofuda: cura"));
      updateBars();
    };

    const useSkip = ()=>{
      if(!running || paused) return;
      if(smoke <= 0) { toastShow(lang==="jp"?"ç…™ãªã—":"Sem fumaÃ§a"); return; }

      smoke--;
      combo = Math.max(1, Math.floor(combo*0.75));
      streak = 0;
      score = Math.max(0, score - 12);

      toastShow(lang==="jp" ? "ğŸŒ«ï¸ å½±é" : (lang==="en" ? "ğŸŒ«ï¸ Smoke escape" : "ğŸŒ«ï¸ Fuga"));
      updateBars();
      nextQuestion();
    };

    // ---------- best score ----------
    const savedBest = ()=> (loadSave()?.best ?? saved.best ?? 0) | 0;
    const setBest = (b)=>{
      const s = loadSave() || {best:0};
      s.best = b|0;
      s.diffIdx = diffIdx;
      s.themeIdx = themeIdx;
      s.lang = lang;
      saveGame(s);
      bestEl.textContent = String(b|0);
    };

    // ---------- pause ----------
    const togglePause = ()=>{
      if(!running) return;
      paused = !paused;
      btnPause.textContent = paused ? I18N[lang].resume : "â¸ï¸ Pausar";
      toastShow(paused ? I18N[lang].pause : (lang==="jp"?"å†é–‹":"Voltou"));
    };

    // ---------- rendering / FX ----------
    let W=0,H=0, DPR=1;
    const resize = ()=>{
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      W = Math.floor(window.innerWidth * DPR);
      H = Math.floor(window.innerHeight * DPR);
      canvas.width = W;
      canvas.height = H;
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
    };
    window.addEventListener("resize", resize);

    // particles (neon rain)
    const drops = [];
    const initDrops = ()=>{
      drops.length = 0;
      const n = Math.round((window.innerWidth * window.innerHeight) / 22000);
      for(let i=0;i<n;i++){
        drops.push({
          x: Math.random(),
          y: Math.random(),
          v: rand(0.25, 1.1),
          len: rand(0.02, 0.08),
          w: rand(0.0006, 0.0018),
          hueOff: rand(-40, 60),
          a: rand(0.12, 0.28)
        });
      }
    };

    // skyline elements
    const towers = [];
    const initTowers = ()=>{
      towers.length = 0;
      const n = Math.max(10, Math.floor(window.innerWidth/90));
      for(let i=0;i<n;i++){
        towers.push({
          x: Math.random(),
          w: rand(0.03, 0.09),
          h: rand(0.12, 0.44),
          flick: rand(0.2, 1.2),
          seed: Math.random()*999
        });
      }
    };

    // Slash FX
    const slashes = [];
    const spawnSlash = (good=true)=>{
      slashes.push({
        t: 0,
        good,
        x: rand(0.2, 0.8),
        y: rand(0.25, 0.65),
        a: rand(-0.9, 0.9)
      });
    };

    // ---------- loop ----------
    let last = performance.now();
    const loop = (now)=>{
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      draw(dt);

      if(running && !paused){
        // timer
        qTimeLeft -= dt;
        if(qTimeLeft <= 0){
          qTimeLeft = 0;
          timeoutFail();
        }

        // blood moon countdown
        if(bloodMoon){
          bloodMoonT -= dt;
          // slowly drain moon
          moon = clamp(moon - 10*dt, 0, 100);
          if(bloodMoonT <= 0) endBloodMoon();
        }else{
          // night meter slowly decays
          moon = clamp(moon - 2.2*dt, 0, 100);
        }

        // music
        musicTick(dt);
        updateBars();
      }

      requestAnimationFrame(loop);
    };

    const draw = (dt)=>{
      ctx.clearRect(0,0,W,H);

      // background gradient
      const themeHue = THEMES[themeIdx].hue;
      const t = performance.now()/1000;

      // subtle vignette
      const g = ctx.createRadialGradient(W*0.5,H*0.35, 0, W*0.5,H*0.55, Math.max(W,H)*0.7);
      g.addColorStop(0, `hsla(${themeHue},90%,55%,${bloodMoon?0.11:0.08})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // skyline
      drawSkyline(themeHue, t);

      // neon rain
      drawRain(themeHue, dt);

      // boss aura + moon
      drawMoon(themeHue, t);

      // slashes
      drawSlashes(dt);

      // pause text
      if(paused && running){
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = `${Math.floor(44*DPR)}px ui-sans-serif, system-ui, sans-serif`;
        ctx.textAlign = "center";
        ctx.fillText(I18N[lang].pause, W/2, H/2);
        ctx.restore();
      }
    };

    const drawSkyline = (hue, t)=>{
      const baseY = H*0.78;
      ctx.save();
      ctx.globalAlpha = 0.95;

      // base fog
      const fog = ctx.createLinearGradient(0, baseY-80*DPR, 0, H);
      fog.addColorStop(0, "rgba(0,0,0,0)");
      fog.addColorStop(1, "rgba(0,0,0,0.75)");
      ctx.fillStyle = fog;
      ctx.fillRect(0, baseY-80*DPR, W, H-(baseY-80*DPR));

      // buildings
      for(const b of towers){
        const x = b.x * W;
        const w = b.w * W;
        const h = b.h * H;
        const y = baseY - h;

        ctx.fillStyle = "rgba(0,0,0,0.45)";
        roundRect(ctx, x, y, w, h, 6*DPR);
        ctx.fill();

        // windows flicker
        const colA = `hsla(${hue+20}, 90%, 60%, ${0.10 + 0.06*Math.sin(t*b.flick + b.seed)})`;
        const colB = `hsla(${hue-30}, 90%, 60%, ${0.08 + 0.05*Math.cos(t*b.flick*0.8 + b.seed)})`;
        ctx.fillStyle = (b.seed%1>0.5) ? colA : colB;

        const cols = Math.max(2, Math.floor(w/(18*DPR)));
        const rows = Math.max(3, Math.floor(h/(22*DPR)));
        for(let i=0;i<cols;i++){
          for(let j=0;j<rows;j++){
            if(((i*13 + j*7 + (b.seed*100|0)) % 9) < 4) continue;
            const wx = x + 6*DPR + i*(w-12*DPR)/cols;
            const wy = y + 10*DPR + j*(h-18*DPR)/rows;
            const ww = Math.max(2*DPR, (w/cols)*0.35);
            const wh = Math.max(3*DPR, (h/rows)*0.28);
            ctx.fillRect(wx, wy, ww, wh);
          }
        }

        // neon sign
        if((b.seed*10|0)%3===0){
          const sy = y + h*rand(0.2,0.7);
          const sx = x + w*rand(0.15,0.75);
          ctx.strokeStyle = `hsla(${hue + (b.seed>0.5?60:-50)}, 92%, 62%, 0.55)`;
          ctx.lineWidth = 2*DPR;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx, sy + 40*DPR);
          ctx.stroke();

          ctx.globalAlpha = 0.35;
          ctx.lineWidth = 6*DPR;
          ctx.stroke();
          ctx.globalAlpha = 0.95;
        }
      }

      // street glow
      const street = ctx.createLinearGradient(0, baseY-10*DPR, 0, H);
      street.addColorStop(0, `hsla(${hue},90%,55%,0.05)`);
      street.addColorStop(1, "rgba(0,0,0,0.85)");
      ctx.fillStyle = street;
      ctx.fillRect(0, baseY-10*DPR, W, H-(baseY-10*DPR));

      ctx.restore();
    };

    const drawRain = (hue, dt)=>{
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(const d of drops){
        d.y += dt * d.v * (bloodMoon ? 1.35 : 1.0);
        if(d.y > 1.2){
          d.y = -0.2;
          d.x = Math.random();
        }
        const x = d.x * W;
        const y = d.y * H;
        const len = d.len * H;
        const w = Math.max(1, d.w * W);

        ctx.strokeStyle = `hsla(${hue + d.hueOff}, 92%, 62%, ${d.a})`;
        ctx.lineWidth = w;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + len);
        ctx.stroke();
      }
      ctx.restore();
    };

    const drawMoon = (hue, t)=>{
      ctx.save();
      const mx = W*0.82;
      const my = H*0.18;
      const r = Math.min(W,H)*0.10;

      // moon glow
      const moonCol = bloodMoon ? `hsla(${hue+140}, 92%, 62%, 0.22)` : `hsla(${hue+10}, 92%, 62%, 0.12)`;
      const mg = ctx.createRadialGradient(mx,my, 0, mx,my, r*2.0);
      mg.addColorStop(0, moonCol);
      mg.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = mg;
      ctx.fillRect(mx-r*2,my-r*2, r*4, r*4);

      // moon disk
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = bloodMoon ? "rgba(255,120,150,0.45)" : "rgba(200,230,255,0.22)";
      ctx.beginPath();
      ctx.arc(mx,my,r,0,Math.PI*2);
      ctx.fill();

      // boss aura ring
      const boss = BOSSES[bossIdx];
      const a = 0.12 + 0.08*Math.sin(t*2.1);
      ctx.globalAlpha = a;
      ctx.strokeStyle = bloodMoon ? "rgba(255,90,130,0.55)" : `hsla(${hue+30}, 92%, 62%, 0.55)`;
      ctx.lineWidth = 3*DPR;
      ctx.beginPath();
      ctx.arc(mx,my, r*1.25, 0, Math.PI*2);
      ctx.stroke();

      // boss glyph near center
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = bloodMoon ? "rgba(255,190,210,0.65)" : "rgba(255,255,255,0.55)";
      ctx.font = `${Math.floor(28*DPR)}px "Noto Sans JP", ui-sans-serif, system-ui`;
      ctx.textAlign = "center";
      ctx.fillText(boss.nameJP, mx, my + 10*DPR);

      ctx.restore();
    };

    const drawSlashes = (dt)=>{
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(let i=slashes.length-1;i>=0;i--){
        const s = slashes[i];
        s.t += dt * (bloodMoon ? 1.6 : 1.2);
        const life = 0.45;
        const p = s.t / life;
        if(p>=1){ slashes.splice(i,1); continue; }

        const x = s.x * W;
        const y = s.y * H;
        const len = lerp(40, 260, p) * DPR;
        const ang = s.a + lerp(-0.25, 0.25, Math.sin(p*Math.PI));
        const dx = Math.cos(ang)*len;
        const dy = Math.sin(ang)*len;

        const alpha = (1-p) * 0.65;
        ctx.strokeStyle = s.good
          ? `rgba(80,255,200,${alpha})`
          : `rgba(255,110,150,${alpha})`;
        ctx.lineWidth = lerp(8,2,p)*DPR;
        ctx.beginPath();
        ctx.moveTo(x-dx*0.5, y-dy*0.5);
        ctx.lineTo(x+dx*0.5, y+dy*0.5);
        ctx.stroke();

        ctx.globalAlpha = 0.25*(1-p);
        ctx.lineWidth *= 2.2;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    };

    const roundRect = (c,x,y,w,h,r)=>{
      const rr = Math.min(r, w/2, h/2);
      c.beginPath();
      c.moveTo(x+rr,y);
      c.arcTo(x+w,y, x+w,y+h, rr);
      c.arcTo(x+w,y+h, x,y+h, rr);
      c.arcTo(x,y+h, x,y, rr);
      c.arcTo(x,y, x+w,y, rr);
      c.closePath();
    };

    // ---------- inputs ----------
    window.addEventListener("keydown",(e)=>{
      const k = e.key.toLowerCase();
      if(k==="p"){ togglePause(); return; }
      if(k==="m"){ setAudio(!audioOn); return; }
      if(k==="h"){ useHeal(); return; }
      if(k==="j"){ useSkip(); return; }

      if(!running || paused) return;
      if(k==="1") answer(0);
      if(k==="2") answer(1);
      if(k==="3") answer(2);
      if(k==="4") answer(3);
    });

    // touch buttons
    tHeal.addEventListener("click", useHeal);
    tSkip.addEventListener("click", useSkip);

    // item chips
    itemOfuda.addEventListener("click", useHeal);
    itemSmoke.addEventListener("click", useSkip);

    // answer click FX: spawn slash on any answer
    answersEl.addEventListener("click",(e)=>{
      const node = e.target.closest(".ans");
      if(!node) return;
      const idx = Number(node.dataset.idx||0);
      const good = curQ ? (idx===curQ._correctIndex) : true;
      spawnSlash(good);
    });

    // buttons
    btnPause.addEventListener("click", togglePause);
    btnAudio.addEventListener("click", ()=>setAudio(!audioOn));
    langSel.addEventListener("change", (e)=>setLang(e.target.value));

    btnStart.addEventListener("click", ()=>startRun());
    btnAgain.addEventListener("click", ()=>startRun());
    btnMenu.addEventListener("click", ()=>{
      gameover.classList.add("hidden");
      menu.classList.remove("hidden");
    });

    btnTutorial.addEventListener("click", ()=>{
      tutorial.classList.remove("hidden");
    });
    btnTutClose.addEventListener("click", ()=>tutorial.classList.add("hidden"));

    btnReset.addEventListener("click", ()=>{
      setBest(0);
      toastShow(lang==="jp" ? "è¨˜éŒ²ãƒªã‚»ãƒƒãƒˆ" : (lang==="en" ? "Best reset" : "Recorde resetado"));
    });

    btnCredits.addEventListener("click", ()=>{
      alert("ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢å…¨çŸ¥å…¨èƒ½ â€” å¤œã®æ¼¢å­—ãƒãƒˆãƒ«\nSingle-file game (no deps)\nÂ© VocÃª + ChatGPT\n\nDica: edite o DB no cÃ³digo para adicionar mais kanji/frases.");
    });

    btnDiff.addEventListener("click", ()=>{
      diffIdx = (diffIdx + 1) % DIFFS.length;
      applyDiff();
      toastShow(lang==="jp" ? `é›£æ˜“åº¦: ${DIFFS[diffIdx].name}` : `Dificuldade: ${DIFFS[diffIdx].name}`);
    });

    btnTheme.addEventListener("click", ()=>{
      themeIdx = (themeIdx + 1) % THEMES.length;
      applyTheme();
      toastShow(lang==="jp" ? `ãƒ†ãƒ¼ãƒ: ${THEMES[themeIdx].name}` : `Tema: ${THEMES[themeIdx].name}`);
    });

    // ---------- init ----------
    const init = ()=>{
      resize();
      initDrops();
      initTowers();

      // show best
      bestEl.textContent = String(savedBest());
      applyDiff();
      applyTheme();
      setLang(lang);

      // default audio off; keep UI consistent
      btnAudio.textContent = I18N[lang].soundOff;
      btnAudio.setAttribute("aria-pressed","false");

      // start loop
      requestAnimationFrame(loop);
    };

    // small polish: click anywhere on menu to allow audio resume on mobile after user gesture
    menu.addEventListener("click", ()=>{
      if(!audioCtx) return;
      audioCtx.resume().catch(()=>{});
    });

    // keep rain & towers in sync with screen changes
    window.addEventListener("resize", ()=>{
      initDrops();
      initTowers();
    });

    init();
  </script>
</body>
</html>
