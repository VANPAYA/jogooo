<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Êó•Êú¨Ë™û„ÉØ„Éº„Éâ„Çµ„Éº„ÉÅ ‚Äî Ca√ßa-Palavras Japon√™s (Atualiza a cada partida)</title>
  <style>
    :root{
      --bg:#070a10;
      --panel:rgba(255,255,255,.08);
      --panel2:rgba(255,255,255,.12);
      --border:rgba(255,255,255,.14);
      --txt:#eef2ff;
      --muted:rgba(238,242,255,.70);
      --muted2:rgba(238,242,255,.55);
      --good:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;

      --hue: 200;
      --a1:hsl(calc(var(--hue) - 20) 92% 60%);
      --a2:hsl(var(--hue) 92% 58%);
      --a3:hsl(calc(var(--hue) + 60) 92% 62%);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --r: 18px;

      --cell: 42px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:
        radial-gradient(1100px 650px at 70% 10%, rgba(80,180,255,.14), transparent 55%),
        radial-gradient(900px 600px at 15% 30%, rgba(255,80,210,.12), transparent 55%),
        radial-gradient(900px 600px at 60% 90%, rgba(60,255,170,.10), transparent 55%),
        var(--bg);
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    .wrap{
      position:fixed; inset:0;
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap:12px;
      padding:14px;
    }

    .hud{
      display:flex; gap:10px; align-items:stretch; flex-wrap:wrap;
    }

    .chip{
      display:flex; gap:12px; align-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid var(--border);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .chip .label{color:var(--muted2); font-size:12px; letter-spacing:.08em; text-transform:uppercase}
    .chip .value{font-weight:900}
    .chip .col{display:flex; flex-direction:column; gap:2px; min-width:90px}

    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      border-radius:999px;
      border:1px solid var(--border);
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color:var(--txt);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      cursor:pointer;
      font-weight:900; font-size:13px;
      transition: transform .08s ease, border-color .2s ease;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.22)}
    .btn:active{transform: translateY(0) scale(.99)}
    .btn[aria-pressed="true"]{outline:2px solid rgba(80,200,255,.25)}

    .select{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.25);
      color: var(--txt);
      padding:9px 10px;
      font-weight:900;
      cursor:pointer;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .main{
      display:grid;
      grid-template-columns: 1.15fr 0.85fr;
      gap:12px;
      min-height:0;
    }
    @media (max-width: 980px){
      .main{grid-template-columns: 1fr; overflow:auto}
    }

    .panel{
      border-radius: var(--r);
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height:0;
    }
    .panel header{
      padding:14px 14px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: linear-gradient(90deg, rgba(80,200,255,.12), rgba(255,80,210,.08), rgba(60,255,170,.08));
      display:flex; align-items:flex-end; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .panel header h1{margin:0; font-size:16px; letter-spacing:.02em}
    .sub{color:var(--muted); font-size:12.5px; line-height:1.4}

    .boardWrap{
      padding:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:0;
    }

    .board{
      display:grid;
      gap:6px;
      padding:10px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
      touch-action:none; /* important */
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      display:grid;
      place-items:center;
      font-weight:900;
      font-size:18px;
      cursor:pointer;
      transition: transform .08s ease, border-color .15s ease, background .15s ease, box-shadow .15s ease;
      position:relative;
      overflow:hidden;
    }
    .cell:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.22)}
    .cell:active{transform: translateY(0) scale(.99)}
    .cell.sel{
      border-color: rgba(251,191,36,.55);
      box-shadow: 0 0 0 2px rgba(251,191,36,.12), 0 0 18px rgba(251,191,36,.18);
      background: rgba(251,191,36,.10);
    }
    .cell.found{
      border-color: rgba(52,211,153,.55);
      box-shadow: 0 0 0 2px rgba(52,211,153,.12), 0 0 18px rgba(52,211,153,.18);
      background: rgba(52,211,153,.10);
    }
    .cell.badflash{
      border-color: rgba(251,113,133,.60);
      background: rgba(251,113,133,.12);
      box-shadow: 0 0 0 2px rgba(251,113,133,.10), 0 0 18px rgba(251,113,133,.18);
    }

    .side{
      padding:14px;
      display:grid;
      gap:12px;
      min-height:0;
    }

    .card{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      padding:14px;
    }
    .card h2{margin:0 0 8px; font-size:13px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase}
    .card p{margin:0; color:var(--muted); line-height:1.55; font-size:14px}

    .words{
      display:grid;
      gap:8px;
      max-height: 46vh;
      overflow:auto;
      padding-right: 6px;
    }
    .w{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
    }
    .w .jp{font-weight:900}
    .w .pt{color:var(--muted); font-size:12.5px}
    .w .tag{
      color: var(--muted2);
      font-size: 12px;
      border:1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 6px 8px;
      background: rgba(0,0,0,.15);
      white-space:nowrap;
      font-weight:900;
    }
    .w.done{
      border-color: rgba(52,211,153,.40);
      background: rgba(52,211,153,.08);
      opacity: .92;
    }
    .w.done .tag{color: rgba(52,211,153,.95); border-color: rgba(52,211,153,.30)}

    .kbd{
      display:inline-block;
      padding:3px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      font-weight:900;
      font-size:12px;
      color:var(--txt);
      margin: 0 3px;
    }

    .toast{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      top:84px;
      z-index:50;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.42);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-weight:900;
      font-size:13px;
      opacity:0;
      pointer-events:none;
      transition: opacity .22s ease, transform .22s ease;
      display:flex; gap:10px; align-items:center;
    }
    .toast.show{opacity:1; transform: translateX(-50%) translateY(0)}
    .dot{width:10px;height:10px;border-radius:99px;background:var(--a2); box-shadow:0 0 14px rgba(80,200,255,.35)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    .footer{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .hintLine{
      color:var(--muted2);
      font-size:12px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }

    @media (max-width: 520px){
      :root{ --cell: 38px; }
      .words{max-height: 40vh;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="chip">
        <div class="col">
          <div class="label">Score</div>
          <div class="value" id="score">0</div>
        </div>
        <div class="col">
          <div class="label">Tempo</div>
          <div class="value mono" id="time">0.0s</div>
        </div>
        <div class="col">
          <div class="label">Best</div>
          <div class="value" id="best">0</div>
        </div>
      </div>

      <div class="chip">
        <div class="col">
          <div class="label">Partida</div>
          <div class="value" id="runId">#000</div>
        </div>
        <div class="col">
          <div class="label">Restantes</div>
          <div class="value" id="left">0</div>
        </div>
      </div>

      <div class="chip">
        <div class="col">
          <div class="label">Dificuldade</div>
          <div class="value" id="diffTxt">Normal</div>
        </div>
        <select class="select" id="diffSel">
          <option value="easy">Easy (10x10)</option>
          <option value="normal" selected>Normal (12x12)</option>
          <option value="hard">Hard (15x15)</option>
        </select>
      </div>

      <div class="chip" style="margin-left:auto;">
        <button class="btn" id="btnNew">üß© Nova partida</button>
        <button class="btn" id="btnHint" aria-pressed="false">üëÅÔ∏è Dica</button>
        <button class="btn" id="btnAudio" aria-pressed="false">üîá Som</button>
      </div>
    </div>

    <div class="main">
      <div class="panel">
        <header>
          <div>
            <h1>Êó•Êú¨Ë™û„ÉØ„Éº„Éâ„Çµ„Éº„ÉÅ ‚Äî Ca√ßa-Palavras</h1>
            <div class="sub">Selecione em linha reta (horizontal/vertical/diagonal). Atualiza automaticamente ao completar.</div>
          </div>
          <div class="sub">
            Teclas: <span class="kbd">N</span> nova ‚Ä¢ <span class="kbd">H</span> dica ‚Ä¢ <span class="kbd">M</span> som
          </div>
        </header>

        <div class="boardWrap">
          <div class="board" id="board" aria-label="Tabuleiro"></div>
        </div>
      </div>

      <div class="panel">
        <header>
          <div>
            <h1>Lista de palavras</h1>
            <div class="sub">Cada partida puxa palavras aleat√≥rias (mix hiragana/katakana/kanji) e reposiciona tudo.</div>
          </div>
          <div class="sub" id="category">‚Äî</div>
        </header>

        <div class="side">
          <div class="card">
            <h2>Gest√£o de risco (setup)</h2>
            <p>
              Aqui o ‚Äúedge‚Äù √© consist√™ncia: procure primeiro diagonais longas (melhor payoff de tempo).
              Use <b>Dica</b> como hedge quando faltar 2 palavras ‚Äî evita drawdown de tempo e maximiza score.
            </p>
          </div>

          <div class="card">
            <h2>Palavras</h2>
            <div class="words" id="words"></div>
          </div>

          <div class="footer">
            <div class="hintLine" id="status">
              <span>Arraste no grid (mouse) ou deslize (toque).</span>
              <span>Sele√ß√£o precisa ser reta.</span>
            </div>
            <button class="btn" id="btnReset">üßπ Resetar best</button>
          </div>
        </div>
      </div>
    </div>

    <div class="toast" id="toast"><span class="dot"></span><span id="toastTxt">‚Äî</span></div>
  </div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  // ---------- Persist ----------
  const KEY = "jp-wordsearch-v1";
  const load = ()=>{ try{ return JSON.parse(localStorage.getItem(KEY) || "null"); }catch{ return null; } };
  const save = (obj)=>{ try{ localStorage.setItem(KEY, JSON.stringify(obj)); }catch{} };
  const saved = load() || { best: 0, runSeq: 0, diff: "normal" };

  // ---------- DOM ----------
  const boardEl = $("board");
  const wordsEl = $("words");
  const scoreEl = $("score");
  const bestEl = $("best");
  const timeEl = $("time");
  const leftEl = $("left");
  const runIdEl = $("runId");
  const statusEl = $("status");
  const toastEl = $("toast");
  const toastTxt = $("toastTxt");
  const categoryEl = $("category");

  const btnNew = $("btnNew");
  const btnHint = $("btnHint");
  const btnAudio = $("btnAudio");
  const btnReset = $("btnReset");

  const diffSel = $("diffSel");
  const diffTxt = $("diffTxt");

  // ---------- Utils ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const pick = (arr)=>arr[(Math.random()*arr.length)|0];
  const shuffle = (arr)=>{
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  };

  const toast = (msg)=>{
    toastTxt.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), 1100);
  };

  // ---------- Audio (procedural) ----------
  let audioOn = false;
  let ac=null, master=null;
  const ensureAudio = ()=>{
    if(ac) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    ac = new AC();
    master = ac.createGain();
    master.gain.value = 0;
    master.connect(ac.destination);
  };
  const setAudio = async(on)=>{
    audioOn = on;
    btnAudio.setAttribute("aria-pressed", String(on));
    btnAudio.textContent = on ? "üîä Som" : "üîá Som";
    if(on){
      ensureAudio();
      try{ await ac.resume(); }catch{}
      master.gain.cancelScheduledValues(ac.currentTime);
      master.gain.setTargetAtTime(0.14, ac.currentTime, 0.06);
    }else if(master && ac){
      master.gain.cancelScheduledValues(ac.currentTime);
      master.gain.setTargetAtTime(0.0, ac.currentTime, 0.05);
    }
  };
  const beep = (f=440, dur=0.08, type="sine", gain=0.12)=>{
    if(!audioOn || !ac) return;
    const t = ac.currentTime;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.setValueAtTime(f, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.connect(g); g.connect(master);
    o.start(t); o.stop(t+dur+0.02);
  };
  const sfx = {
    ok(){ beep(880,0.06,"triangle",0.10); beep(1320,0.05,"sine",0.08); },
    bad(){ beep(180,0.12,"sawtooth",0.12); },
    win(){ beep(440,0.09,"square",0.08); beep(660,0.08,"triangle",0.08); beep(880,0.07,"sine",0.07); },
    hint(){ beep(520,0.06,"triangle",0.08); },
    start(){ beep(220,0.10,"square",0.08); beep(440,0.08,"triangle",0.08); }
  };

  // ---------- Japanese filler chars ----------
  const HIRA = "„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù„Åü„Å°„Å§„Å¶„Å®„Å™„Å´„Å¨„Å≠„ÅÆ„ÅØ„Å≤„Åµ„Å∏„Åª„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ„ÇÑ„ÇÜ„Çà„Çâ„Çä„Çã„Çå„Çç„Çè„Çì„Åå„Åé„Åê„Åí„Åî„Åñ„Åò„Åö„Åú„Åû„Å†„Å¢„Å•„Åß„Å©„Å±„Å¥„Å∑„Å∫„ÅΩ";
  const KATA = "„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≥„Ç¨„ÇÆ„Ç∞„Ç≤„Ç¥„Éë„Éî„Éó„Éö„Éù";
  const fillerChar = ()=>{
    // mix
    const src = Math.random()<0.82 ? HIRA : KATA;
    return src[(Math.random()*src.length)|0];
  };

  // ---------- Vocabulary pools (mix kana/kanji/katakana) ----------
  // jp: string (word), pt: meaning
  const POOLS = [
    {
      name: "üå∏ Sakura & Cidade",
      words: [
        {jp:"„Åï„Åè„Çâ", pt:"cerejeira"},
        {jp:"„Å®„ÅÜ„Åç„Çá„ÅÜ", pt:"T√≥quio"},
        {jp:"ÈßÖ", pt:"esta√ß√£o"},
        {jp:"„Åß„Çì„Åó„ÇÉ", pt:"trem"},
        {jp:"„Åó„Çì„Åã„Çì„Åõ„Çì", pt:"shinkansen"},
        {jp:"„Åø„Å°", pt:"caminho"},
        {jp:"„Åæ„Å§„Çä", pt:"festival"},
        {jp:"„ÇÑ„Åü„ÅÑ", pt:"barraca (festival)"},
        {jp:"„Å≠„Åä„Çì", pt:"neon"},
        {jp:"Â§ú", pt:"noite"},
        {jp:"Èõ®", pt:"chuva"},
        {jp:"Ê©ã", pt:"ponte"},
      ]
    },
    {
      name: "üçú Comida",
      words: [
        {jp:"„Åô„Åó", pt:"sushi"},
        {jp:"„É©„Éº„É°„É≥", pt:"ramen"},
        {jp:"„Åä„Å°„ÇÉ", pt:"ch√°"},
        {jp:"„Åø„Åö", pt:"√°gua"},
        {jp:"„Åî„ÅØ„Çì", pt:"arroz/refei√ß√£o"},
        {jp:"„Åü„Åæ„Åî", pt:"ovo"},
        {jp:"„Åï„Åë", pt:"salm√£o / saqu√™ (depende)"},
        {jp:"„ÇÑ„Åï„ÅÑ", pt:"legumes"},
        {jp:"„Åè„Å†„ÇÇ„ÅÆ", pt:"frutas"},
        {jp:"„ÅÇ„Åæ„ÅÑ", pt:"doce"},
        {jp:"Ëæõ„ÅÑ", pt:"apimentado"},
        {jp:"„Å´„Åè", pt:"carne"},
      ]
    },
    {
      name: "ü¶ä Yokai & M√≠stico",
      words: [
        {jp:"„Åç„Å§„Å≠", pt:"raposa"},
        {jp:"„Åä„Å´", pt:"ogro/dem√¥nio"},
        {jp:"„ÇÜ„ÅÜ„Çå„ÅÑ", pt:"fantasma"},
        {jp:"„Åæ„Åª„ÅÜ", pt:"magia"},
        {jp:"„Åë„Å£„Åã„ÅÑ", pt:"barreira"},
        {jp:"„Åä„Åµ„Å†", pt:"talism√£"},
        {jp:"ÂΩ±", pt:"sombra"},
        {jp:"Èóá", pt:"escurid√£o"},
        {jp:"Êúà", pt:"lua"},
        {jp:"Ë°Ä", pt:"sangue"},
        {jp:"ÂàÄ", pt:"katana/espada"},
        {jp:"„Åæ„ÇÇ„Çã", pt:"proteger"},
      ]
    },
    {
      name: "üéí B√°sico (N5-ish)",
      words: [
        {jp:"Âèã„Å†„Å°", pt:"amigo"},
        {jp:"Â≠¶Áîü", pt:"estudante"},
        {jp:"ÂÖàÁîü", pt:"professor"},
        {jp:"Â≠¶Ê†°", pt:"escola"},
        {jp:"Êú¨", pt:"livro"},
        {jp:"ÂêçÂâç", pt:"nome"},
        {jp:"ÊôÇÈñì", pt:"tempo"},
        {jp:"‰ªäÊó•", pt:"hoje"},
        {jp:"ÊòéÊó•", pt:"amanh√£"},
        {jp:"ÂÖÉÊ∞ó", pt:"bem/disposto"},
        {jp:"„Åô„Åç", pt:"gostar"},
        {jp:"Ë°å„Åè", pt:"ir"},
      ]
    }
  ];

  // ---------- Difficulty ----------
  const DIFF = {
    easy:   { label:"Easy",   size:10, words: 8,  maxTries: 900 },
    normal: { label:"Normal", size:12, words: 10, maxTries: 1200 },
    hard:   { label:"Hard",   size:15, words: 12, maxTries: 1600 },
  };

  let diff = saved.diff in DIFF ? saved.diff : "normal";
  diffSel.value = diff;
  diffTxt.textContent = DIFF[diff].label;

  // ---------- Game state ----------
  let gridSize = DIFF[diff].size;
  let grid = [];            // 2D array of chars
  let cells = [];           // 2D array of cell elements
  let placedWords = [];     // [{jp, pt, coords:[{r,c}]}]
  let remaining = new Set(); // word indices remaining
  let foundCoords = new Set(); // "r,c" string marked as found

  let score = 0;
  let best = saved.best|0;

  let runSeq = saved.runSeq|0;
  let runId = "000";

  let running = false;
  let startT = 0;
  let tNow = 0;
  let raf = 0;

  // Selection state
  let selecting = false;
  let selStart = null; // {r,c}
  let selEnd = null;   // {r,c}
  let selLine = [];    // coords
  let hintOn = false;

  // ---------- Build grid ----------
  const DIRS = [
    {dr:0, dc:1}, {dr:0, dc:-1},
    {dr:1, dc:0}, {dr:-1, dc:0},
    {dr:1, dc:1}, {dr:1, dc:-1},
    {dr:-1, dc:1}, {dr:-1, dc:-1},
  ];

  const toChars = (s)=>[...s]; // handles kana/kanji fine

  const emptyGrid = (n)=>{
    const g = Array.from({length:n}, ()=>Array.from({length:n}, ()=>""));
    return g;
  };

  const inBounds = (r,c,n)=> r>=0 && c>=0 && r<n && c<n;

  const canPlace = (g, wordChars, r0,c0, dr,dc)=>{
    const n = g.length;
    for(let i=0;i<wordChars.length;i++){
      const r = r0 + dr*i;
      const c = c0 + dc*i;
      if(!inBounds(r,c,n)) return false;
      const cur = g[r][c];
      if(cur!=="" && cur!==wordChars[i]) return false;
    }
    return true;
  };

  const doPlace = (g, wordChars, r0,c0, dr,dc)=>{
    const coords = [];
    for(let i=0;i<wordChars.length;i++){
      const r = r0 + dr*i;
      const c = c0 + dc*i;
      g[r][c] = wordChars[i];
      coords.push({r,c});
    }
    return coords;
  };

  const generatePuzzle = ()=>{
    // reset
    selecting=false; selStart=null; selEnd=null; selLine=[];
    foundCoords.clear();

    // choose pool and words
    const pool = pick(POOLS);
    categoryEl.textContent = pool.name;

    const conf = DIFF[diff];
    gridSize = conf.size;
    grid = emptyGrid(gridSize);

    // pick N words (favor longer)
    const candidates = shuffle(pool.words)
      .sort((a,b)=>toChars(b.jp).length - toChars(a.jp).length);

    const picked = [];
    for(const w of candidates){
      if(picked.length >= conf.words) break;
      // avoid too-short spam
      if(toChars(w.jp).length < 2) continue;
      picked.push(w);
    }

    placedWords = [];
    remaining = new Set();

    // place words
    for(let wi=0; wi<picked.length; wi++){
      const w = picked[wi];
      const chars = toChars(w.jp);

      let placed = false;
      for(let t=0; t<conf.maxTries; t++){
        const dir = pick(DIRS);
        const r0 = (Math.random()*gridSize)|0;
        const c0 = (Math.random()*gridSize)|0;
        if(!canPlace(grid, chars, r0,c0, dir.dr, dir.dc)) continue;
        const coords = doPlace(grid, chars, r0,c0, dir.dr, dir.dc);
        placedWords.push({jp:w.jp, pt:w.pt, coords});
        remaining.add(placedWords.length-1);
        placed = true;
        break;
      }

      // if fail, skip (rare), but keep puzzle playable
      if(!placed){
        // no-op
      }
    }

    // fill empties
    for(let r=0;r<gridSize;r++){
      for(let c=0;c<gridSize;c++){
        if(grid[r][c]==="") grid[r][c]=fillerChar();
      }
    }

    // build UI
    renderBoard();
    renderWords();

    // state
    score = 0;
    scoreEl.textContent = score|0;
    bestEl.textContent = best|0;

    runSeq++;
    runId = String(runSeq).padStart(3,"0");
    runIdEl.textContent = "#" + runId;

    leftEl.textContent = String(remaining.size);

    // timer
    running = true;
    startT = performance.now();
    cancelAnimationFrame(raf);
    tick();
    toast("Nova grade gerada. Bora ca√ßar.");
    sfx.start();

    // persist
    save({best, runSeq, diff});
  };

  const renderBoard = ()=>{
    boardEl.innerHTML = "";
    boardEl.style.gridTemplateColumns = `repeat(${gridSize}, var(--cell))`;
    boardEl.style.gridTemplateRows = `repeat(${gridSize}, var(--cell))`;

    cells = Array.from({length:gridSize}, ()=>Array.from({length:gridSize}, ()=>null));

    for(let r=0;r<gridSize;r++){
      for(let c=0;c<gridSize;c++){
        const d = document.createElement("div");
        d.className = "cell";
        d.textContent = grid[r][c];
        d.dataset.r = String(r);
        d.dataset.c = String(c);
        d.setAttribute("role","button");
        d.setAttribute("aria-label", `c√©lula ${r+1},${c+1}`);

        cells[r][c]=d;
        boardEl.appendChild(d);
      }
    }
  };

  const renderWords = ()=>{
    wordsEl.innerHTML = "";
    placedWords.forEach((w, idx)=>{
      const item = document.createElement("div");
      item.className = "w";
      item.id = "w_" + idx;
      item.innerHTML = `
        <div>
          <div class="jp">${w.jp}</div>
          <div class="pt">${w.pt}</div>
        </div>
        <div class="tag">PENDENTE</div>
      `;
      wordsEl.appendChild(item);
    });
  };

  // ---------- Timer / Score ----------
  const tick = ()=>{
    if(!running) return;
    tNow = (performance.now() - startT)/1000;
    timeEl.textContent = tNow.toFixed(1) + "s";
    raf = requestAnimationFrame(tick);
  };

  const scoreForWord = (len)=>{
    // score = length * base, with time pressure
    // Quanto mais r√°pido, maior o payoff (estilo trader: execu√ß√£o eficiente).
    const timeFactor = clamp(1.35 - (tNow/120), 0.75, 1.35);
    return Math.round((18 + len*10) * timeFactor);
  };

  // ---------- Selection logic ----------
  const key = (r,c)=>`${r},${c}`;
  const clearTempSelection = ()=>{
    // remove .sel from non-found
    for(let r=0;r<gridSize;r++){
      for(let c=0;c<gridSize;c++){
        const el = cells[r][c];
        if(!el) continue;
        if(el.classList.contains("sel") && !el.classList.contains("found")){
          el.classList.remove("sel");
        }
      }
    }
  };

  const applyLineHighlight = (line)=>{
    clearTempSelection();
    for(const p of line){
      const el = cells[p.r][p.c];
      if(!el) continue;
      if(el.classList.contains("found")) continue;
      el.classList.add("sel");
    }
  };

  const getLine = (a,b)=>{
    const r1=a.r, c1=a.c, r2=b.r, c2=b.c;
    const dr = r2-r1;
    const dc = c2-c1;

    const sgn = (x)=> x===0 ? 0 : (x>0 ? 1 : -1);
    const sdr = sgn(dr);
    const sdc = sgn(dc);

    const adr = Math.abs(dr);
    const adc = Math.abs(dc);

    // Must be straight or diagonal
    if(!(dr===0 || dc===0 || adr===adc)) return [];

    const steps = Math.max(adr, adc);
    if(steps===0) return [{r:r1,c:c1}];

    const line = [];
    for(let i=0;i<=steps;i++){
      const rr = r1 + sdr*i;
      const cc = c1 + sdc*i;
      if(!inBounds(rr,cc,gridSize)) return [];
      line.push({r:rr,c:cc});
    }
    return line;
  };

  const lineToString = (line)=>{
    let s="";
    for(const p of line) s += grid[p.r][p.c];
    return s;
  };

  const flashBad = (line)=>{
    for(const p of line){
      const el = cells[p.r][p.c];
      if(!el) continue;
      if(el.classList.contains("found")) continue;
      el.classList.add("badflash");
      setTimeout(()=>el.classList.remove("badflash"), 140);
    }
  };

  const markFound = (idx)=>{
    const w = placedWords[idx];
    for(const p of w.coords){
      foundCoords.add(key(p.r,p.c));
      const el = cells[p.r][p.c];
      if(el){
        el.classList.remove("sel");
        el.classList.add("found");
      }
    }
    remaining.delete(idx);
    leftEl.textContent = String(remaining.size);

    const item = $("w_"+idx);
    if(item){
      item.classList.add("done");
      const tag = item.querySelector(".tag");
      if(tag) tag.textContent = "OK";
    }
  };

  const tryResolveSelection = ()=>{
    if(!selLine.length) return;

    const s1 = lineToString(selLine);
    const s2 = [...s1].reverse().join(""); // reverse selection allowed

    let hit = -1;
    for(const idx of remaining){
      if(placedWords[idx].jp === s1 || placedWords[idx].jp === s2){
        hit = idx;
        break;
      }
    }

    if(hit !== -1){
      const len = [...placedWords[hit].jp].length;
      const add = scoreForWord(len);
      score += add;
      scoreEl.textContent = score|0;

      markFound(hit);
      toast(`‚úÖ ${placedWords[hit].jp}  +${add}`);
      sfx.ok();

      // Win?
      if(remaining.size === 0){
        running = false;
        cancelAnimationFrame(raf);

        // bonus de fechamento r√°pido
        const winBonus = Math.round(clamp(900 - tNow*18, 120, 900));
        score += winBonus;
        scoreEl.textContent = score|0;

        if(score > best){
          best = score|0;
          bestEl.textContent = best|0;
          save({best, runSeq, diff});
        }

        toast(`üèÆ Limpo. +${winBonus} b√¥nus. Nova partida...`);
        sfx.win();

        // auto next game
        setTimeout(()=>generatePuzzle(), 900);
      }
    }else{
      flashBad(selLine);
      toast("‚ùå N√£o √© palavra da lista.");
      sfx.bad();
    }
  };

  // ---------- Hint ----------
  const setHint = (on)=>{
    hintOn = on;
    btnHint.setAttribute("aria-pressed", String(on));
    if(on){
      btnHint.textContent = "üëÅÔ∏è Dica ON";
      statusEl.innerHTML = `<span>Modo Dica: a primeira letra de 1 palavra restante pisca no grid.</span><span>(Desliga automaticamente em 4s)</span>`;
      sfx.hint();

      // pick one remaining word and blink first coord
      const idx = pick([...remaining]);
      if(idx !== undefined){
        const p = placedWords[idx].coords[0];
        const el = cells[p.r][p.c];
        if(el){
          let k=0;
          const iv = setInterval(()=>{
            if(!hintOn){ clearInterval(iv); return; }
            el.classList.toggle("sel");
            k++;
            if(k>10){ clearInterval(iv); el.classList.remove("sel"); }
          }, 180);
        }
      }

      setTimeout(()=>setHint(false), 4000);
    }else{
      btnHint.textContent = "üëÅÔ∏è Dica";
      statusEl.innerHTML = `<span>Arraste no grid (mouse) ou deslize (toque).</span><span>Sele√ß√£o precisa ser reta.</span>`;
      clearTempSelection();
    }
  };

  // ---------- Pointer input (mouse + touch) ----------
  const getCellFromEvent = (e)=>{
    const t = e.target.closest(".cell");
    if(!t) return null;
    const r = Number(t.dataset.r);
    const c = Number(t.dataset.c);
    if(Number.isNaN(r) || Number.isNaN(c)) return null;
    return {r,c, el:t};
  };

  const onDown = (e)=>{
    // allow audio resume on mobile gesture
    if(ac) ac.resume().catch(()=>{});

    const hit = getCellFromEvent(e);
    if(!hit) return;
    e.preventDefault();
    selecting = true;
    selStart = {r:hit.r, c:hit.c};
    selEnd = {r:hit.r, c:hit.c};
    selLine = getLine(selStart, selEnd);
    applyLineHighlight(selLine);
    boardEl.setPointerCapture?.(e.pointerId);
  };

  const onMove = (e)=>{
    if(!selecting) return;
    const hit = getCellFromEvent(e);
    if(!hit) return;
    e.preventDefault();
    selEnd = {r:hit.r, c:hit.c};
    selLine = getLine(selStart, selEnd);
    applyLineHighlight(selLine);
  };

  const onUp = (e)=>{
    if(!selecting) return;
    e.preventDefault();
    selecting = false;
    tryResolveSelection();
    clearTempSelection();
  };

  // bind pointer events to board
  boardEl.addEventListener("pointerdown", onDown);
  boardEl.addEventListener("pointermove", onMove);
  window.addEventListener("pointerup", onUp);

  // ---------- Controls ----------
  const setDiff = (d)=>{
    diff = d;
    diffTxt.textContent = DIFF[diff].label;
    save({best, runSeq, diff});
    generatePuzzle();
  };

  btnNew.addEventListener("click", ()=>generatePuzzle());
  btnHint.addEventListener("click", ()=>setHint(!hintOn));
  btnAudio.addEventListener("click", ()=>setAudio(!audioOn));
  btnReset.addEventListener("click", ()=>{
    best = 0;
    bestEl.textContent = "0";
    save({best, runSeq, diff});
    toast("Best resetado.");
  });

  diffSel.addEventListener("change", (e)=>setDiff(e.target.value));

  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if(k==="n") generatePuzzle();
    if(k==="h") setHint(!hintOn);
    if(k==="m") setAudio(!audioOn);
  });

  // ---------- Init ----------
  bestEl.textContent = String(best|0);
  runSeq = saved.runSeq|0;

  // Start with saved diff
  diffSel.value = diff;
  diffTxt.textContent = DIFF[diff].label;

  // start puzzle
  generatePuzzle();

})();
</script>
</body>
</html>
